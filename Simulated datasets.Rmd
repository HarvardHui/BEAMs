---
title: "Assessing the Impact of Batch Effect Associated Missing Values on Functional Analysis in High-Throughput Biomedical Data"
author: "Harvard Wai Hann Hui"
date: "2024-10-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load the libraries
```{r}
library(corrplot)
library(gtools)
library(ggplot2)
library(ggfortify)
library(mice)
library(sva)
library(vegan)
library(imputeLCMD)
library(limma)
library(reshape2)
library(missForest)
library(ggrepel)
library(dplyr)
library(grid)
library(gridExtra)
library(pROC)
library(ggpubr)
library(pheatmap)
library(visdat)
library(magrittr)
library(MESS)
library(mvdalab)
library(ggplotify)
library(ggdist)
library(here)

wd <- here()
source(paste0(wd, "/BEAMs/functions.r"))
```

Set parameters for the simulations
```{r}
# Simulation parameters
nbatches = 4 # number of batches
nclasses = 2 # number of classes
classbatch_samples = 5 # number of samples in each class-batch
batch_samples = classbatch_samples*nclasses # number of samples in a batch
nfeatures = 1000 # number of features
nsamples = nbatches * nclasses * classbatch_samples # total number of samples
iterations = 20 # number of iterations

# Create class-batch matrix for simulating data
bc_mat = matrix(classbatch_samples, nrow=nclasses, ncol=nbatches)
```

Simulate datasets
```{r}
# Save datasets
save_sim <- vector("list", length = iterations)
save_datasets <- vector("list", length = iterations)

# Set seed for reproducibility
seed = 1234
set.seed(seed)

# Simulate the datasets
for (iter in 1:iterations){
  set.seed(iter)
  microdf = simulate_microarray(nfeatures, bc_mat, gamma=0.5, phi=0.2, epsilon=0.5, dropout = FALSE, seed=seed, c=10, d=8)
  batch_df = microdf$X
  save_sim[[iter]] <- microdf
  save_datasets[[iter]] <- batch_df
}

# Set the meta data
pdat = microdf$metadata
class_factor = as.factor(pdat$class)
batch_factor = as.factor(pdat$batch)
```

Simulate missing values
```{r}
# MV proportions simulated
mv_prop = 0.40
mnar_ratio = 0.7

save_batch_mv_prop = c()
save_beams <- c()
save_beam_df <- vector("list", length = iterations)
save_control_df <- vector("list", length = iterations)
save_beam_true <- vector("list", length = iterations)
save_control_true <- vector("list", length = iterations)
for (iter in 1:iterations){
  set.seed(iter)
  seed = iter
  
  # Insert BEAMs
  beam.df = jin.MNAR(batch_df, mv_prop, mnar_ratio, beams = T, batch_factor = batch_factor, seed=seed)
  
  # Recalculate missingness proportion to insert into control
  new_mv_prop = sum(is.na(beam.df$msdata))/length(beam.df$msdata)
  
  # Insert Control MVs
  control.df = jin.MNAR(batch_df, new_mv_prop, mnar_ratio, beams = F, batch_factor = batch_factor, seed=seed)
  
  beam_df <- beam.df$msdata
  control_df <- control.df$msdata
  
  rownames(control_df) = seq(nrow(save_datasets[[iter]]))
  rownames(beam_df) = seq(nrow(save_datasets[[iter]]))
  rownames(save_datasets[[iter]]) = seq(nrow(save_datasets[[iter]]))
  
  # Remove features with too many missing values
  control_df = filter.mvs(control_df, (nsamples-batch_samples)/nsamples) %>% quantileNormByClass(., class_factor)
  control_true = save_datasets[[iter]][rownames(control_df),] %>% quantileNormByClass(., class_factor)
  beam_df = filter.mvs(beam_df, (nsamples-batch_samples)/nsamples) %>% quantileNormByClass(., class_factor)
  beam_true = save_datasets[[iter]][rownames(beam_df),] %>% quantileNormByClass(., class_factor)

  save_beam_df[[iter]] <- beam_df
  save_control_df[[iter]] <- control_df
  save_beam_true[[iter]] <- beam_true
  save_control_true[[iter]] <- control_true
}

# To plot missing value distribution heatmaps
# Run CPTAC file first

# ms_cptac <- cptac_df %>% as.data.frame() %>% .[sample(1:nrow(.), nrow(.), replace=F),] %>% vis_miss(., show_perc_col = F) + theme(axis.text.x = element_blank(), plot.title=element_text(vjust=-4)) + labs(title="(A) CPTAC dataset \n")
# ms_control <- vis_miss(as.data.frame(control_df), show_perc_col = F) + theme(axis.text.x = element_blank(), plot.title=element_text(vjust=-4)) + labs(title="(B) Simulated \n (control) dataset")
# ms_beam <- vis_miss(as.data.frame(beam_df), show_perc_col = F) + theme(axis.text.x = element_blank(), plot.title=element_text(vjust=-4)) + labs(title="(C) Simulated \n (BEAMs) dataset")
# ms_all <- ggarrange(ms_cptac, ms_control, ms_beam, ncol=3, nrow=1)
# annotate_figure(ms_all, top=text_grob("Missing value distributions", face="bold", size=14))
```


Impute missing values
```{r}
batch_samples = nsamples/nbatches

save_Control_list <- vector("list", length = iterations)
save_BEAM_list <- vector("list", length = iterations)

for (iter in 1:iterations){
  # Set seed for reproducibility
  set.seed(iter)
  
  # Perform missing value imputation using KNN, MinProb, mean, and SVD
  KNN_control = do.knn(save_control_df[[iter]], k=floor(sqrt(nsamples/2)))
  MinProb_control = impute.MinProb(save_control_df[[iter]], tune.sigma=0.5)
  Mean_control = mean.imp(save_control_df[[iter]])
  SVD_control = t(impute.wrapper.SVD(t(save_control_df[[iter]]), K=3))
  
  KNN_beam = do.knn(save_beam_df[[iter]], k=floor(sqrt(nsamples/2)))
  MinProb_beam = impute.MinProb(save_beam_df[[iter]], tune.sigma=0.5)
  Mean_beam = mean.imp(save_beam_df[[iter]])
  SVD_beam = t(impute.wrapper.SVD(t(save_beam_df[[iter]]), K=3))
  
  # Save imputed datasets
  Control_list = list(`Ground truth`=save_control_true[[iter]], KNN=KNN_control, MinProb=MinProb_control, Mean=Mean_control, SVD=SVD_control)
  BEAM_list = list(`Ground truth`=save_beam_true[[iter]], KNN=KNN_beam, MinProb=MinProb_beam, Mean=Mean_beam, SVD=SVD_beam)
  
  save_Control_list[[iter]] <- Control_list
  save_BEAM_list[[iter]] <- BEAM_list
}
```

Correct batch effect by ComBat
```{r}
save_ComBat_Control_list <- vector("list", length = iterations)
save_ComBat_BEAM_list <- vector("list", length = iterations)
#### Apply BECAS
for (iter in 1:iterations){
  # Set seed for reproducibility
  set.seed(iter)
  
  # Apply ComBat
  ComBat_Control_list = lapply(save_Control_list[[iter]], function(x) do.combat.sim(x, pdat, cov=F))
  ComBat_BEAM_list = lapply(save_BEAM_list[[iter]], function(x) do.combat.sim(x, pdat, cov=F))
  
  # Save batch corrected datasets
  save_ComBat_Control_list[[iter]] <- ComBat_Control_list
  save_ComBat_BEAM_list[[iter]] <- ComBat_BEAM_list
}

```

Check TPR, FPR, Precision of DEA
```{r, fig.width=8, fig.height=8}
save_DEA_results <- vector("list", length = iterations)
for (iter in 1:iterations){
  # Get the true differential features
  control_trues <- save_sim[[iter]]$diff.features[which(save_sim[[iter]]$diff.features %in% rownames(save_control_df[[iter]]))]
  beam_trues <- save_sim[[iter]]$diff.features[which(save_sim[[iter]]$diff.features %in% rownames(save_beam_df[[iter]]))]
  
  ###### TPR Calculation
  BEAM_tpr = lapply(save_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="tpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Uncorrected")
  Control_tpr = lapply(save_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="tpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Uncorrected")
  ComBat_BEAM_tpr = lapply(save_ComBat_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="tpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Corrected")
  ComBat_Control_tpr = lapply(save_ComBat_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="tpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Corrected")
  
  tpr_res <- rbind(Control_tpr, BEAM_tpr, ComBat_Control_tpr, ComBat_BEAM_tpr) %>% mutate(., Group=factor(.$Group, levels=c("Control Uncorrected","BEAM Uncorrected","Control Corrected","BEAM Corrected")))

  
  ###### FPR Calculation
  BEAM_fpr = lapply(save_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="fpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Uncorrected")
  Control_fpr = lapply(save_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="fpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Uncorrected")
  ComBat_BEAM_fpr = lapply(save_ComBat_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="fpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Corrected")
  ComBat_Control_fpr = lapply(save_ComBat_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="fpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Corrected")
  
  fpr_res <- rbind(Control_fpr, BEAM_fpr, ComBat_Control_fpr, ComBat_BEAM_fpr) %>% mutate(., Group=factor(.$Group, levels=c("Control Uncorrected","BEAM Uncorrected","Control Corrected","BEAM Corrected")))

  ###### Precision Calculation
  BEAM_precision = lapply(save_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="precision", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Uncorrected")
  Control_precision = lapply(save_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="precision", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Uncorrected")
  ComBat_BEAM_precision = lapply(save_ComBat_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="precision", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Corrected")
  ComBat_Control_precision = lapply(save_ComBat_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="precision", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Corrected")
  
  precision_res <- rbind(Control_precision, BEAM_precision, ComBat_Control_precision, ComBat_BEAM_precision) %>% mutate(., Group=factor(.$Group, levels=c("Control Uncorrected","BEAM Uncorrected","Control Corrected","BEAM Corrected")))

  ###### F-score Calculation
  BEAM_fscore = lapply(save_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="fscore", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Uncorrected")
  Control_fscore = lapply(save_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="fscore", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Uncorrected")
  ComBat_BEAM_fscore = lapply(save_ComBat_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="fscore", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Corrected")
  ComBat_Control_fscore = lapply(save_ComBat_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="fscore", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Corrected")
  
  fscore_res <- rbind(Control_fscore, BEAM_fscore, ComBat_Control_fscore, ComBat_BEAM_fscore) %>% mutate(., Group=factor(.$Group, levels=c("Control Uncorrected","BEAM Uncorrected","Control Corrected","BEAM Corrected")))
  
  # Save results
  save_DEA_results[[iter]]$TPR <- tpr_res
  save_DEA_results[[iter]]$FPR <- fpr_res
  save_DEA_results[[iter]]$Precision <- precision_res
  save_DEA_results[[iter]]$Fscore <- fscore_res

}

# Plot the results
plot_TPR <- DEA_to_plot(save_DEA_results ,output="TPR")
plot_FPR <- DEA_to_plot(save_DEA_results ,output="FPR")
plot_Precision <- DEA_to_plot(save_DEA_results ,output="Precision")
plot_Fscore <- DEA_to_plot(save_DEA_results ,output="Fscore")

dea1 = ggplot(plot_TPR, aes(x=x, y=mean, fill=data)) +
  geom_col(position="dodge", width=0.6) +
  geom_errorbar( aes(x=x, ymin=mean-sd, ymax=mean+sd), width=0.3, size=0.5, colour="black", alpha=0.9, position = position_dodge(0.6), stat = "identity") +
  labs(x="", y="TPR (%)", fill="Dataset", title="(A) TPR (%)") + scale_fill_hue() +
  ylim(0,100) +
  theme(legend.position = "bottom", plot.title = element_text(size=15), legend.text=element_text(face="bold"), axis.text=element_text(face="bold"), axis.text.x = element_text(angle=45, vjust=1, hjust=1), strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold")) + facet_grid(~bec, scales="free_y")

dea2 = ggplot(plot_FPR, aes(x=x, y=mean, fill=data)) +
  geom_col(position="dodge", width=0.6) +
  geom_errorbar( aes(x=x, ymin=pmax(mean-sd,0), ymax=mean+sd), width=0.3, size=0.5, colour="black", alpha=0.9, position = position_dodge(0.6), stat = "identity") +
  labs(x="", y="FPR (%)", fill="Dataset", title="(B) FPR (%)") + scale_fill_hue() +
  ylim(0,15) +
theme(legend.position = "bottom", plot.title = element_text(size=15), legend.text=element_text(face="bold"), axis.text=element_text(face="bold"), axis.text.x = element_text(angle=45, vjust=1, hjust=1),strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold")) + facet_grid(~bec, scales="free_y")

dea3 = ggplot(plot_Precision, aes(x=x, y=mean, fill=data)) +
  geom_col(position="dodge", width=0.6) +
  geom_errorbar( aes(x=x, ymin=mean-sd, ymax=mean+sd), width=0.3, size=0.5, colour="black", alpha=0.9, position = position_dodge(0.6), stat = "identity") +
  labs(x="", y="Precision (%)", fill="Dataset", title="(C) Precision (%)") + scale_fill_hue() +
    ylim(0,102) +
theme(legend.position = "bottom", plot.title = element_text(size=15), legend.text=element_text(face="bold"), axis.text=element_text(face="bold"), axis.text.x = element_text(angle=45, vjust=1, hjust=1),strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold")) + facet_grid(~bec, scales="free_y")

dea4 = ggplot(plot_Fscore, aes(x=x, y=mean, fill=data)) +
  geom_col(position="dodge", width=0.6) +
  geom_errorbar( aes(x=x, ymin=mean-sd, ymax=mean+sd), width=0.3, size=0.5, colour="black", alpha=0.9, position = position_dodge(0.6), stat = "identity") +
  labs(x="", y="F-score (%)", fill="Dataset", title="(D) F-score (%)") + scale_fill_hue() +
  ylim(0,100) +
theme(legend.position = "bottom", plot.title = element_text(size=15), legend.text=element_text(face="bold"), axis.text=element_text(face="bold"), axis.text.x = element_text(angle=45, vjust=1, hjust=1),strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold")) + facet_grid(~bec, scales="free_y")

deaplot.1 = ggarrange(dea1, dea2, dea3, dea4, common.legend = T, legend = "bottom")
annotate_figure(deaplot.1, top = text_grob("Simulated (Control and BEAMs) datasets", 
               color = "black", face = "bold", size = 14), bottom = text_grob("MVI method", vjust=-4))

# png("C:/Users/Harvard/Desktop/Research/BEAMs/png2/figure 9 new.png", width=1400, height=1400, res=200)
# annotate_figure(deaplot.1, top = text_grob("Simulated (Control and BEAMs) datasets",
#                color = "black", face = "bold", size = 14), bottom = text_grob("MVI method", vjust=-4))
# dev.off()
```

Batch effect metrics (PVCA, silhouette width, pcRegression)
```{r}
save_PCA <- vector("list", length = iterations)
save_pcReg <- vector("list", length = iterations)
for (iter in 1:iterations){
  # Remove differential features
  rm_features <- save_sim[[iter]]$diff.features
  save_Control_list2 <- lapply(save_Control_list[[iter]], function(x) x[-which(rownames(x) %in% rm_features),])
  save_BEAM_list2 <- lapply(save_BEAM_list[[iter]], function(x) x[-which(rownames(x) %in% rm_features),])
  save_ComBat_Control_list2 <- lapply(save_ComBat_Control_list[[iter]], function(x) x[-which(rownames(x) %in% rm_features),])
  save_ComBat_BEAM_list2 <- lapply(save_ComBat_BEAM_list[[iter]], function(x) x[-which(rownames(x) %in% rm_features),])

  #### Perform PCA on data
  Control_PCA = lapply(save_Control_list2, function(x) prcomp(t(x), scale.=T, center=T))
  BEAM_PCA = lapply(save_BEAM_list2, function(x) prcomp(t(x), scale.=T, center=T))
  ComBat_Control_PCA = lapply(save_ComBat_Control_list2, function(x) prcomp(t(x), scale.=T, center=T))
  ComBat_BEAM_PCA = lapply(save_ComBat_BEAM_list2, function(x) prcomp(t(x), scale.=T, center=T))

  save_PCA[[iter]]$Control <- Control_PCA
  save_PCA[[iter]]$BEAM <- BEAM_PCA
  save_PCA[[iter]]$ComBat_Control <- ComBat_Control_PCA
  save_PCA[[iter]]$ComBat_BEAM <- ComBat_BEAM_PCA

  #### pcRegression
  ## Regress PCs on the batch factor
  Control_pcReg = lapply(Control_PCA, function(x) {
    res=kBET::pcRegression(x, batch_factor)$maxVar
    res=sum(res)/100
    return(res)
    }) %>% as.data.frame() %>% melt() %>% mutate(., Group="Uncorrected simulated (control) dataset")
  ComBat_Control_pcReg = lapply(ComBat_Control_PCA, function(x) {
    res=kBET::pcRegression(x, batch_factor)$maxVar
    res=sum(res)/100
    return(res)
    }) %>% as.data.frame() %>% melt() %>% mutate(., Group="Corrected simulated (control) dataset")
  BEAM_pcReg = lapply(BEAM_PCA, function(x) {
    res=kBET::pcRegression(x, batch_factor)$maxVar
    res=sum(res)/100
    return(res)
    }) %>% as.data.frame() %>% melt() %>% mutate(., Group="Uncorrected simulated (BEAMs) dataset")
  ComBat_BEAM_pcReg = lapply(ComBat_BEAM_PCA, function(x) {
    res=kBET::pcRegression(x, batch_factor)$maxVar
    res=sum(res)/100
    return(res)
    }) %>% as.data.frame() %>% melt() %>% mutate(., Group="Corrected simulated (BEAMs) dataset")
  
  all_pcReg = rbind(Control_pcReg, BEAM_pcReg, ComBat_Control_pcReg, ComBat_BEAM_pcReg)
  
  # Save the results
  save_pcReg[[iter]]<- all_pcReg
}

# Plot the results
plot_pcReg <- do.call(rbind, save_pcReg)
pcReg_mean <- aggregate(plot_pcReg$value, by=list(group=plot_pcReg$Group, imp=plot_pcReg$variable), FUN=mean)
pcReg_sd <- aggregate(plot_pcReg$value, by=list(group=plot_pcReg$Group, imp=plot_pcReg$variable), FUN=sd)
pcReg_mean$sd <- pcReg_sd$x
plot_pcReg <- pcReg_mean %>% mutate(., group=factor(.$group, levels=c("Uncorrected simulated (control) dataset","Uncorrected simulated (BEAMs) dataset","Corrected simulated (control) dataset","Corrected simulated (BEAMs) dataset")))
rm(pcReg_mean);rm(pcReg_sd)
colnames(plot_pcReg) <- c("group", "x", "mean", "sd")
plot_pcReg$x[is.na(plot_pcReg$x)] <- "Ground truth"
plot_pcReg$x <- factor(plot_pcReg$x, levels=c("Ground truth","KNN","Mean","MinProb","SVD"))

# Reformat the labels for facet_grid
plot_pcReg$data <- case_when(grepl("control",plot_pcReg$group) == T ~ "Simulated (control) dataset",
                             grepl("BEAMs",plot_pcReg$group) == T ~ "Simulated (BEAMs) dataset") %>% factor(., levels = c("Simulated (control) dataset","Simulated (BEAMs) dataset"))
plot_pcReg$bec <- case_when(grepl("Uncorrected",plot_pcReg$group) == T ~ "Uncorrected",
                             grepl("Corrected",plot_pcReg$group) == T ~ "Corrected") %>% factor(., levels = c("Uncorrected","Corrected"))

ggplot(plot_pcReg, aes(x=x, y=mean, fill=group)) +
  geom_col(position="dodge") +
  geom_errorbar( aes(x=x, ymin=mean-sd, ymax=mean+sd), width=0.3, size=0.7, colour="black", alpha=0.9, position = position_dodge(0.9), stat = "identity") +
  labs(x="", y="pcRegression score", fill="", title="") + scale_fill_hue() + theme(legend.position = "none", plot.title = element_text(size=15, face="bold"), axis.text=element_text(face="bold"), legend.text=element_text(face="bold")) + ylim(0,1) + guides(fill = guide_legend(nrow = 2)) + facet_wrap(~group, nrow=2, ncol=2)

ggplot(plot_pcReg, aes(x=x, y=mean, fill=group)) +
  geom_col(position="dodge") +
  geom_errorbar( aes(x=x, ymin=mean-sd, ymax=mean+sd), width=0.3, size=0.5, colour="black", alpha=0.9, position = position_dodge(0.9), stat = "identity") +
  labs(x="MVI method", y="pcRegression score", fill="", title="") + scale_fill_hue() + theme(legend.position = "none", plot.title = element_text(size=15, face="bold"), axis.text.x=element_text(face="bold", angle=45, vjust=1,hjust=1), legend.text=element_text(face="bold")) + ylim(0,1) + guides(fill = guide_legend(nrow = 2)) + facet_grid(bec ~ data)


# png("C:/Users/Harvard/Desktop/Research/BEAMs/png2/figure 5 new.png", width=1200, height=800, res=200)
# ggplot(plot_pcReg, aes(x=x, y=mean, fill=group)) +
#   geom_col(position="dodge") +
#   geom_errorbar( aes(x=x, ymin=mean-sd, ymax=mean+sd), width=0.3, size=0.5, colour="black", alpha=0.9, position = position_dodge(0.9), stat = "identity") +
#   labs(x="MVI method", y="pcRegression score", fill="", title="") + scale_fill_hue() + theme(legend.position = "none", plot.title = element_text(size=15, face="bold"), axis.text.x=element_text(face="bold", angle=45, vjust=1,hjust=1), legend.text=element_text(face="bold")) + ylim(0,1) + guides(fill = guide_legend(nrow = 2)) + facet_grid(bec ~ data)
# dev.off()
```

Create PCA plot data
```{r, fig.width=10, fig.height=10, dpi=300}
temp_list = as.list(c("Ground truth","KNN","MinProb","Mean","SVD"))
plot_Control_PCA <- lapply(temp_list, function(res){
  out = Control_PCA[[res]]$x[,1:2] %>% as.data.frame() %>% mutate(., Group=res, Batch=batch_factor, Class=class_factor)
  return(out)
  }) %>% do.call("rbind", .) %>% mutate(., Group=factor(.$Group, levels=c("Ground truth","KNN","Mean","MinProb","SVD")), bec="Uncorrected")
plot_ComBat_Control_PCA <- lapply(temp_list, function(res){
  out = ComBat_Control_PCA[[res]]$x[,1:2] %>% as.data.frame() %>% mutate(., Group=res, Batch=batch_factor, Class=class_factor)
  return(out)
  }) %>% do.call("rbind", .) %>% mutate(., Group=factor(.$Group, levels=c("Ground truth","KNN","Mean","MinProb","SVD")), bec="Corrected")
plot_BEAM_PCA <- lapply(temp_list, function(res){
  out = BEAM_PCA[[res]]$x[,1:2] %>% as.data.frame() %>% mutate(., Group=res, Batch=batch_factor, Class=class_factor)
  return(out)
  }) %>% do.call("rbind", .) %>% mutate(., Group=factor(.$Group, levels=c("Ground truth","KNN","Mean","MinProb","SVD")), bec="Uncorrected")
plot_ComBat_BEAM_PCA <- lapply(temp_list, function(res){
  out = ComBat_BEAM_PCA[[res]]$x[,1:2] %>% as.data.frame() %>% mutate(., Group=res, Batch=batch_factor, Class=class_factor)
  return(out)
  }) %>% do.call("rbind", .) %>% mutate(., Group=factor(.$Group, levels=c("Ground truth","KNN","Mean","MinProb","SVD")), bec="Corrected")

plot_pca_control <- rbind(plot_Control_PCA, plot_ComBat_Control_PCA) %>% mutate(., bec=factor(.$bec,levels=c("Uncorrected","Corrected")))
plot_pca_beam <- rbind(plot_BEAM_PCA, plot_ComBat_BEAM_PCA) %>% mutate(., bec=factor(.$bec,levels=c("Uncorrected","Corrected")))

pcaplot1=ggplot(plot_Control_PCA, aes(x=PC1, y=PC2, fill=Batch, shape=Class)) + geom_point(size=3) + facet_wrap(~Group, ncol=5) + labs(title="(C) Uncorrected") + theme(legend.position = "bottom", strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold"), title=element_text(face="bold"), axis.text = element_text(face="bold")) + scale_shape_manual(values=c(21,24)) + guides(fill = guide_legend(override.aes = list(shape=21)))

pcaplot2=ggplot(plot_ComBat_Control_PCA, aes(x=PC1, y=PC2, fill=Batch, shape=Class)) + geom_point(size=3) + facet_wrap(~Group, ncol=5) + labs(title="(D) Corrected") + theme(legend.position = "bottom", strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold"), title=element_text(face="bold"), axis.text = element_text(face="bold")) + scale_shape_manual(values=c(21,24)) + guides(fill = guide_legend(override.aes = list(shape=21)))

pcaplot3=ggplot(plot_BEAM_PCA, aes(x=PC1, y=PC2, fill=Batch, shape=Class)) + geom_point(size=3) + facet_wrap(~Group, ncol=5) + labs(title="(E) Uncorrected") + theme(legend.position = "bottom", strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold"), title=element_text(face="bold"), axis.text = element_text(face="bold")) + scale_shape_manual(values=c(21,24)) + guides(fill = guide_legend(override.aes = list(shape=21)))

pcaplot4=ggplot(plot_ComBat_BEAM_PCA, aes(x=PC1, y=PC2, fill=Batch, shape=Class)) + geom_point(size=3) + facet_wrap(~Group, ncol=5) + labs(title="(F) Corrected") + theme(legend.position = "bottom", strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold"), title=element_text(face="bold"), axis.text = element_text(face="bold")) + scale_shape_manual(values=c(21,24)) + guides(fill = guide_legend(override.aes = list(shape=21)))

sim_pca_plot <- ggarrange(pcaplot1, pcaplot2, pcaplot3, pcaplot4, nrow=4, ncol=1, common.legend = T, legend="bottom")
annotate_figure(sim_pca_plot, top = text_grob("Simulation (Control and BEAMs)", 
               color = "black", face = "bold", size = 16))
```

Remove true differential features and check t-test p-value distribution
```{r, fig.height=6, fig.width=12}
save_all_ttest_results <- vector("list", length = iterations)
save_ComBat_all_ttest_results <- vector("list", length = iterations)


for (iter in 1:iterations){
  # Identify and remove true differential features
  rm_features <- save_sim[[iter]]$diff.features
  save_Control_list2 <- lapply(save_Control_list[[iter]], function(x) x[-which(rownames(x) %in% rm_features),])
  save_BEAM_list2 <- lapply(save_BEAM_list[[iter]], function(x) x[-which(rownames(x) %in% rm_features),])
  save_ComBat_Control_list2 <- lapply(save_ComBat_Control_list[[iter]], function(x) x[-which(rownames(x) %in% rm_features),])
  save_ComBat_BEAM_list2 <- lapply(save_ComBat_BEAM_list[[iter]], function(x) x[-which(rownames(x) %in% rm_features),])

  # Perform t-test on the imputed datasets
  Control_ttest = lapply(save_Control_list2, function(x) t.test.sim(x, class_factor, output="pvals"))
  BEAM_ttest = lapply(save_BEAM_list2, function(x) t.test.sim(x, class_factor, output="pvals"))
  
  ttest_results = as.data.frame(Control_ttest) %>% set_colnames(., c(c("Ground truth","KNN","MinProb","Mean","SVD"))) %>% melt() %>% mutate(., Group="Simulated (control)")
  
  BEAM_ttest_results = as.data.frame(BEAM_ttest) %>% set_colnames(., c(c("Ground truth","KNN","MinProb","Mean","SVD"))) %>% melt() %>% mutate(., Group="Simulated (BEAMs)")
  
  all_ttest_results = rbind(ttest_results, BEAM_ttest_results) %>% mutate(., variable = ordered(.$variable, levels=c("Ground truth","KNN","Mean","MinProb","SVD")))
  
  # Repeat on the ComBat corrected datasets
  ComBat_Control_ttest = lapply(save_ComBat_Control_list2, function(x) t.test.sim(x, class_factor, output="pvals"))
  ComBat_BEAM_ttest = lapply(save_ComBat_BEAM_list2, function(x) t.test.sim(x, class_factor, output="pvals"))
  
  ComBat_ttest_results = as.data.frame(ComBat_Control_ttest) %>% set_colnames(., c(c("Ground truth","KNN","MinProb","Mean","SVD"))) %>% melt() %>% mutate(., Group="Simulated (control)")
  
  ComBat_BEAM_ttest_results = as.data.frame(ComBat_BEAM_ttest) %>% set_colnames(., c(c("Ground truth","KNN","MinProb","Mean","SVD"))) %>% melt() %>% mutate(., Group="Simulated (BEAMs)")
  
  ComBat_all_ttest_results = rbind(ComBat_ttest_results, ComBat_BEAM_ttest_results) %>% mutate(., variable = ordered(.$variable, levels=c("Ground truth","KNN","Mean","MinProb","SVD")))
  
  # Save the results
  save_all_ttest_results[[iter]] <- all_ttest_results
  save_ComBat_all_ttest_results[[iter]] <- ComBat_all_ttest_results
}

# Plot the results
plot_all_ttest <- do.call(rbind, save_all_ttest_results)
p1=ggplot(plot_all_ttest, aes(x=value, fill=Group)) + geom_histogram(alpha=0.6, position="identity") + labs(title="(A) Uncorrected",x="BH-adjusted p-value", fill="Dataset") + facet_wrap(~variable, ncol=5, scales="free_y") + theme(axis.text.x=element_text(angle=45,vjust=1,hjust=0.8), strip.text = element_text(face="bold"), axis.text=element_text(face="plain"), legend.text = element_text(face="bold"))

plot_ComBat_all_ttest <- do.call(rbind, save_ComBat_all_ttest_results)
p2=ggplot(plot_ComBat_all_ttest, aes(x=value, fill=Group)) + geom_histogram(alpha=0.6, position="identity") + labs(title="(B) Corrected",x="BH-adjusted p-value", fill="Dataset") + facet_wrap(~variable, ncol=5, scales="free_y") + theme(axis.text.x=element_text(angle=45,vjust=1,hjust=0.8), strip.text = element_text(face="bold"), axis.text=element_text(face="plain"), legend.text = element_text(face="bold"))

plot_tt2 <- ggarrange(p1,p2,ncol=1,nrow=2, common.legend = T, legend="bottom")
annotate_figure(plot_tt2, top = text_grob("Simulated (Control and BEAMs) datasets", 
               color = "black", face = "bold", size = 14))
```

Subset the BEAMs data matrices feature-wise by 3 levels of BEAMs severity
```{r}
# Set seed for reproducibility
set.seed(1234)

#### Identify which features belong to which subset
# Discovered by one batch only (Severe BEAMs)
by1 = check_beams(beam_df, pdat$class, pdat$batch)
by1_df = beam_df[by1,]
# Missing in at least one batch (Moderate BEAMs)
ms_by1 = check_beams(beam_df, pdat$class, pdat$batch, by_single_batch = F)
ms_by1_only = ms_by1
ms_by1_only[by1 == TRUE] = FALSE
ms_by1_only_df = beam_df[ms_by1_only,]
# Non-BEAMs
ms_df = beam_df[ms_by1==FALSE,]


#### Extract Features from each category
# Discovered by one batch only (Severe BEAMs)
imp_by1_df = lapply(BEAM_list, function(x) x[by1,])
bc_imp_by1_df = lapply(ComBat_BEAM_list, function(x) x[by1,])

# Missing in at least one batch (Moderate BEAMs)
imp_ms_by1_only_df = lapply(BEAM_list, function(x) x[ms_by1_only,])
bc_imp_ms_by1_only_df = lapply(ComBat_BEAM_list, function(x) x[ms_by1_only,])

# Non-BEAMs
imp_ms_df = lapply(BEAM_list, function(x) x[ms_by1==FALSE,])
bc_imp_ms_df = lapply(ComBat_BEAM_list, function(x) x[ms_by1==FALSE,])

#### Remove differential features
rm_features = microdf$diff.features

diff_by1=which(rownames(imp_by1_df$`Ground truth`) %in% rm_features)
diff_ms_by1=which(rownames(imp_ms_by1_only_df$`Ground truth`) %in% rm_features)
diff_ms=which(rownames(imp_ms_df$`Ground truth`) %in% rm_features)

if (length(diff_by1) > 0){
  diff_removed_by1 = lapply(imp_by1_df, function(x) x[-diff_by1,])
  bc_diff_removed_by1 = lapply(bc_imp_by1_df, function(x) x[-diff_by1,])
} else {
  diff_removed_by1 = imp_by1_df
  bc_diff_removed_by1 = bc_imp_by1_df
}
if (length(diff_ms_by1) > 0){
  diff_removed_ms_by1 = lapply(imp_ms_by1_only_df, function(x) x[-diff_ms_by1,])
  bc_diff_removed_ms_by1 = lapply(bc_imp_ms_by1_only_df, function(x) x[-diff_ms_by1,])
} else {
  diff_removed_ms_by1 = imp_ms_by1_only_df
  bc_diff_removed_ms_by1 = bc_imp_ms_by1_only_df
}
if (length(diff_ms) > 0){
  diff_removed_ms = lapply(imp_ms_df, function(x) x[-diff_ms,])
  bc_diff_removed_ms = lapply(bc_imp_ms_df, function(x) x[-diff_ms,])
} else {
  diff_removed_ms = imp_ms_df
  bc_diff_removed_ms = bc_imp_ms_df
}

#### Find subset with fewest features, then under-sample other subsets to the same size
subset_features=c(nrow(diff_removed_by1$`Ground truth`), nrow(diff_removed_ms_by1$`Ground truth`), nrow(diff_removed_ms$`Ground truth`))
fewest_features_subset=which(subset_features == min(subset_features))

ind1 = sample(x=seq(subset_features[1]),
              size=subset_features[fewest_features_subset],
              replace=FALSE)
ind2 = sample(x=seq(subset_features[2]),
              size=subset_features[fewest_features_subset],
              replace=FALSE)
ind3 = sample(x=seq(subset_features[3]),
              size=subset_features[fewest_features_subset],
              replace=FALSE)
sampled_by1 = lapply(diff_removed_by1, function(x) x[ind1,])
sampled_ms_by1 = lapply(diff_removed_ms_by1, function(x) x[ind2,])
sampled_ms = lapply(diff_removed_ms, function(x) x[ind3,])
bc_sampled_by1 = lapply(bc_diff_removed_by1, function(x) x[ind1,])
bc_sampled_ms_by1 = lapply(bc_diff_removed_ms_by1, function(x) x[ind2,])
bc_sampled_ms = lapply(bc_diff_removed_ms, function(x) x[ind3,])
```

Correlation heatmaps
```{r, fig.height = 8, fig.width = 12}
###### Correlation heatmap

# Assign annotation labels and colors
anno<-data.frame(row.names=colnames(beam_df), Batch=paste0("Batch_",batch_factor), Class=paste0("Class_",class_factor))
annoCol<-list(Batch=c(Batch_1="blue", Batch_2="red", Batch_3="orange", Batch_4="grey", Batch_5="purple1", Batch_6="black", Batch_7="yellow", Batch_8="pink", Batch_9="magenta", Batch_10="darkgreen"),
              Class=c(Class_0="yellow",
                      Class_1="black"))

# Perform Pearsons correlation and plot the heatmaps
helper_list <- as.list(1:5)
label_names <- c("Ground truth","KNN","MinProb","Mean","SVD")
corheatmaps <- lapply(helper_list, function(x){
  cor_mat = cor(na.omit(sampled_by1[[x]]), method='pearson', use='complete.obs')
  h1=pheatmap(cor_mat, cluster_rows = T,cluster_cols = T, color=blues9, main="",
           show_colnames = F, show_rownames = F, annotation_col = anno, annotation_colors = annoCol,
           annotation_legend = F, silent = T, treeheight_row = 0) %>% as.ggplot()
  cor_mat = cor(na.omit(sampled_ms_by1[[x]]), method='pearson', use='complete.obs')
  h2=pheatmap(cor_mat, cluster_rows = T,cluster_cols = T, color=blues9, main="",
           show_colnames = F, show_rownames = F, annotation_col = anno, annotation_colors = annoCol,
           annotation_legend = F, silent = T, treeheight_row = 0) %>% as.ggplot()
  cor_mat = cor(na.omit(sampled_ms[[x]]), method='pearson', use='complete.obs')
  h3=pheatmap(cor_mat, cluster_rows = T,cluster_cols = T, color=blues9, main="",
           show_colnames = F, show_rownames = F, annotation_col = anno, annotation_colors = annoCol,
           annotation_legend = F, silent = T, treeheight_row = 0) %>% as.ggplot()
  
  # Corrected
  cor_mat = cor(na.omit(bc_sampled_by1[[x]]), method='pearson', use='complete.obs')
  h4=pheatmap(cor_mat, cluster_rows = T,cluster_cols = T, color=blues9, main="",
           show_colnames = F, show_rownames = F, annotation_col = anno, annotation_colors = annoCol,
           annotation_legend = F, silent = T, treeheight_row = 0) %>% as.ggplot()
  cor_mat = cor(na.omit(bc_sampled_ms_by1[[x]]), method='pearson', use='complete.obs')
  h5=pheatmap(cor_mat, cluster_rows = T,cluster_cols = T, color=blues9, main="",
           show_colnames = F, show_rownames = F, annotation_col = anno, annotation_colors = annoCol,
           annotation_legend = F, silent = T, treeheight_row = 0) %>% as.ggplot()
  cor_mat = cor(na.omit(bc_sampled_ms[[x]]), method='pearson', use='complete.obs')
  h6=pheatmap(cor_mat, cluster_rows = T,cluster_cols = T, color=blues9, main="",
          show_colnames = F, show_rownames = F, annotation_col = anno, annotation_colors = annoCol,
           annotation_legend = F, silent = T, treeheight_row = 0) %>% as.ggplot()
  # out_plot = ggarrange(h1[[4]],h2[[4]],h3[[4]],h4[[4]],h5[[4]],h6[[4]], common.legend=T, legend="bottom")
  out_plot = ggarrange(h3,h2,h1,h6,h5,h4, common.legend=T, legend="bottom")

  # Create title
  text_grob <- text_grob(label = label_names[x], 
                       face = "bold", 
                       size = 16, 
                       hjust = 0.5)
  out_plot <- annotate_figure(out_plot, top = text_grob)
})

for (i in 1:5){
  print(corheatmaps[[i]])
}
```

Plot a feature from the severe BEAMs group in a KNN imputed dataset to see what caused the p-value inflation
```{r, fig.height=6}
# Find a feature with inflated p-value
pvals <- BEAM_ttest$KNN[rownames(sampled_by1$KNN)] # Extract the p-values
signif <- which(pvals < 0.05)
feat <- signif[1]
ori_feature <- data.frame(values=sampled_by1$`Ground truth`[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Ground truth")
imp_feature <- data.frame(values=sampled_by1$KNN[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Imputed")
all_feature <- rbind(ori_feature, imp_feature)

# Separate batches by vertical line
batch_lines <- seq(from=0, to=nsamples, by=(classbatch_samples*2)) %>% .[-c(1, length(.))]
batch_lines <- batch_lines + 0.5


par(mfrow=c(2,2))
plot(sampled_by1$`Ground truth`[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(A) Ground truth", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(beam_df[rownames(sampled_by1$`Ground truth`)[feat],], col=class_factor, pch=19, main="", ylab="",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(B) BEAMs introduced", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(sampled_by1$KNN[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(C) KNN imputed", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(bc_sampled_by1$KNN[feat,], col=class_factor, pch=19, main="", ylab="",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(D) KNN imputed and ComBat corrected", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)
```

Plot a feature from the moderate BEAMs group in a mean imputed dataset to see what caused the poor batch effect correction
```{r, fig.height=6}
# Find a feature with inflated p-value
pvals <- BEAM_ttest$Mean[rownames(sampled_ms_by1$Mean)] # Extract the p-values
signif <- which(pvals < 0.05)
feat <- 3
ori_feature <- data.frame(values=sampled_ms_by1$`Ground truth`[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Ground truth")
imp_feature <- data.frame(values=sampled_ms_by1$Mean[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Imputed")
all_feature <- rbind(ori_feature, imp_feature)

# Separate batches by vertical line
batch_lines <- seq(from=0, to=nsamples, by=(classbatch_samples*2)) %>% .[-c(1, length(.))]
batch_lines <- batch_lines + 0.5

par(mfrow=c(2,2))
plot(sampled_ms_by1$`Ground truth`[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(A) `Ground truth`", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(beam_df[rownames(sampled_ms_by1$`Ground truth`)[feat],], col=class_factor, pch=19, main="", ylab="",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(B) BEAMs introduced", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(sampled_ms_by1$Mean[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(C) Mean imputed", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(bc_sampled_ms_by1$Mean[feat,], col=class_factor, pch=19, main="", ylab="",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(D) Mean imputed and ComBat corrected", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)
```

Plot a feature from the severe BEAMs group in a MinProb imputed dataset to see what caused the p-value inflation
```{r, fig.height=6}
# Find a feature with inflated p-value
pvals <- BEAM_ttest$MinProb[rownames(sampled_by1$MinProb)] # Extract the p-values
signif <- which(pvals < 0.05)
feat <- 1#signif[2]
ori_feature <- data.frame(values=sampled_by1$`Ground truth`[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Ground truth")
imp_feature <- data.frame(values=sampled_by1$MinProb[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Imputed")
all_feature <- rbind(ori_feature, imp_feature)

# Separate batches by vertical line
batch_lines <- seq(from=0, to=nsamples, by=(classbatch_samples*2)) %>% .[-c(1, length(.))]
batch_lines <- batch_lines + 0.5

par(mfrow=c(2,2))
plot(sampled_by1$`Ground truth`[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(A) `Ground truth`", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(beam_df[rownames(sampled_by1$`Ground truth`)[feat],], col=class_factor, pch=19, main="", ylab="",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(B) BEAMs introduced", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(sampled_by1$MinProb[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(C) MinProb imputed", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(bc_sampled_by1$MinProb[feat,], col=class_factor, pch=19, main="", ylab="",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(D) MinProb imputed and ComBat corrected", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)
```

Plot a feature from the severe BEAMs group in a SVD imputed dataset to see what caused the p-value inflation
```{r, fig.height=6}
# Find a feature with inflated p-value
pvals <- BEAM_ttest$SVD[rownames(sampled_by1$SVD)] # Extract the p-values
signif <- which(pvals < 0.05)
feat <- 1#signif[2]
ori_feature <- data.frame(values=sampled_by1$`Ground truth`[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Ground truth")
imp_feature <- data.frame(values=sampled_by1$SVD[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Imputed")
all_feature <- rbind(ori_feature, imp_feature)

# Separate batches by vertical line
batch_lines <- seq(from=0, to=nsamples, by=(classbatch_samples*2)) %>% .[-c(1, length(.))]
batch_lines <- batch_lines + 0.5

par(mfrow=c(2,2))
plot(sampled_by1$`Ground truth`[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(A) `Ground truth`", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(beam_df[rownames(sampled_by1$`Ground truth`)[feat],], col=class_factor, pch=19, main="", ylab="",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(B) BEAMs introduced", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(sampled_by1$SVD[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(C) SVD imputed", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(bc_sampled_by1$SVD[feat,], col=class_factor, pch=19, main="", ylab="",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(D) SVD imputed and ComBat corrected", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)
```

Session info
```{r}
sessionInfo()
```
