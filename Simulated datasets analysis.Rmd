---
title: "Assessing the Impact of Batch Effect Associated Missing Values on Downstream Analysis in High-Throughput Biomedical Data"
author: "Harvard Wai Hann Hui"
date: "2025-02-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load the libraries
```{r}
library(corrplot)
library(gtools)
library(ggplot2)
library(ggfortify)
library(mice)
library(sva)
library(vegan)
library(imputeLCMD)
library(limma)
library(reshape2)
library(missForest)
library(ggrepel)
library(dplyr)
library(grid)
library(gridExtra)
library(pROC)
library(ggpubr)
library(pheatmap)
library(visdat)
library(magrittr)
library(MESS)
library(mvdalab)
library(ggplotify)
library(ggdist)
library(here)

wd <- here()
source(paste0(wd, "/BEAMs-main/BEAMs-main/functions.r"))
```

Set parameters for the simulations
```{r}
# Simulation parameters
nbatches = 4 # number of batches
nclasses = 2 # number of classes
classbatch_samples = 5 # number of samples in each class-batch
batch_samples = classbatch_samples*nclasses # number of samples in a batch
nfeatures = 1000 # number of features
nsamples = nbatches * nclasses * classbatch_samples # total number of samples

iterations = 10 # number of iterations

BECA_method = "ComBat" # Selection of BECA (ComBat or limma)

# MV proportions simulated
mv_prop = 0.40 # Total MV percentage
mnar_ratio = 0.8 # MNAR proportion (change to 0.2 for MCAR dominant analysis)

# Create class-batch matrix for simulating data
bc_mat = matrix(classbatch_samples, nrow=nclasses, ncol=nbatches)
```

Simulate datasets
```{r}
# Save datasets
save_sim <- vector("list", length = iterations)
save_datasets <- vector("list", length = iterations)

# Set seed for reproducibility
seed = 1234
set.seed(seed)

# Simulate the datasets
for (iter in 1:iterations){
  set.seed(iter)
  microdf = simulate_microarray(nfeatures, bc_mat, gamma=0.5, phi=0.2, epsilon=0.5, dropout = FALSE, seed=iter, c=10, d=8)
  batch_df = microdf$X
  save_sim[[iter]] <- microdf
  save_datasets[[iter]] <- batch_df
}

# Set the meta data
pdat = microdf$metadata
class_factor = as.factor(pdat$class)
batch_factor = as.factor(pdat$batch)

```

Simulate missing values
```{r}
save_batch_mv_prop = c()
save_beams <- c()
save_beam_df <- vector("list", length = iterations)
save_control_df <- vector("list", length = iterations)
save_beam_true <- vector("list", length = iterations)
save_control_true <- vector("list", length = iterations)
save_ComBat_beam_true <- vector("list", length = iterations)
save_ComBat_control_true <- vector("list", length = iterations)

for (iter in 1:iterations){
  set.seed(iter)
  seed = iter
  
  # Insert BEAMs
  beam.df = jin.MNAR(save_datasets[[iter]], mv_prop, mnar_ratio, beams = T, batch_factor = batch_factor, seed=seed)
  
  # Recalculate missingness proportion to insert into control
  new_mv_prop = sum(is.na(beam.df$msdata))/length(beam.df$msdata)
  
  # Insert Control MVs
  control.df = jin.MNAR(save_datasets[[iter]], new_mv_prop, mnar_ratio, beams = F, batch_factor = batch_factor, seed=seed)
  
  # Assign MV matrices
  beam_df <- beam.df$msdata
  control_df <- control.df$msdata
  
  # Assign rownames
  rownames(control_df) = seq(nrow(save_datasets[[iter]]))
  rownames(beam_df) = seq(nrow(save_datasets[[iter]]))
  rownames(save_datasets[[iter]]) = seq(nrow(save_datasets[[iter]]))

  # Remove features with too many missing values
  control_df = filter.mvs(control_df, (nsamples-batch_samples)/nsamples) %>% quantileNormByClass(., class_factor)
  beam_df = filter.mvs(beam_df, (nsamples-batch_samples)/nsamples) %>% quantileNormByClass(., class_factor)

  # Find feature intersect
  feature_intersect <- intersect(rownames(control_df), rownames(beam_df))
  control_df <- control_df[feature_intersect,] %>% quantileNormByClass(., class_factor)
  beam_df <- beam_df[feature_intersect,] %>% quantileNormByClass(., class_factor)
  
  # Reduce datasets to same feature sets and normalize
  control_true = save_datasets[[iter]][rownames(control_df),] %>% quantileNormByClass(., class_factor)
  beam_true = save_datasets[[iter]][rownames(beam_df),] %>% quantileNormByClass(., class_factor)

  control_true = save_datasets[[iter]][rownames(control_df),] %>% quantileNormByClass(., class_factor)
  beam_true = save_datasets[[iter]][rownames(beam_df),] %>% quantileNormByClass(., class_factor)
  
  if (BECA_method == "ComBat"){
    # Apply ComBat
    ComBat_control_true = save_datasets[[iter]][rownames(control_df),] %>%
      quantileNormByClass(., class_factor) %>%
      do.combat.sim(., pdat=pdat, cov=F)
    ComBat_beam_true = save_datasets[[iter]][rownames(beam_df),] %>%
      quantileNormByClass(., class_factor) %>%
      do.combat.sim(., pdat=pdat, cov=F)
  }
  if (BECA_method == "limma"){
    # Apply Limma (variables are still named ComBat)
      ComBat_control_true = save_datasets[[iter]][rownames(control_df),] %>%
      quantileNormByClass(., class_factor) %>%
      limma::removeBatchEffect(., batch=pdat$batch)
    ComBat_beam_true = save_datasets[[iter]][rownames(beam_df),] %>%
      quantileNormByClass(., class_factor) %>%
      limma::removeBatchEffect(., batch=pdat$batch)
  }
  # Save datasets
  save_beam_df[[iter]] <- beam_df
  save_control_df[[iter]] <- control_df
  save_beam_true[[iter]] <- beam_true
  save_control_true[[iter]] <- control_true
  save_ComBat_beam_true[[iter]] <- ComBat_beam_true
  save_ComBat_control_true[[iter]] <- ComBat_control_true
}

# To plot missing value distribution heatmaps (Main manuscript Figure 2)
# Run CPTAC file first

# ms_cptac <- cptac_df %>% as.data.frame() %>% .[sample(1:nrow(.), nrow(.), replace=F),] %>% vis_miss(., show_perc_col = F) + theme(axis.text.x = element_blank(), plot.title=element_text(vjust=-4)) + labs(title="(A) CPTAC dataset \n")
# ms_control <- vis_miss(as.data.frame(control_df), show_perc_col = F) + theme(axis.text.x = element_blank(), plot.title=element_text(vjust=-4)) + labs(title="(B) Simulated \n (control) dataset")
# ms_beam <- vis_miss(as.data.frame(beam_df), show_perc_col = F) + theme(axis.text.x = element_blank(), plot.title=element_text(vjust=-4)) + labs(title="(C) Simulated \n (BEAMs) dataset")
# ms_all <- ggarrange(ms_cptac, ms_control, ms_beam, ncol=3, nrow=1)
# annotate_figure(ms_all, top=text_grob("Missing value distributions", face="bold", size=14))
```


Impute missing values
```{r}
batch_samples = nsamples/nbatches

save_Control_list <- vector("list", length = iterations)
save_BEAM_list <- vector("list", length = iterations)

for (iter in 1:iterations){
  # Set seed for reproducibility
  set.seed(iter)
  
  # Perform missing value imputation using KNN, MinProb, mean, and SVD
  KNN_control = do.knn(save_control_df[[iter]], k=floor(sqrt(nsamples/2)))
  MinProb_control = impute.MinProb(save_control_df[[iter]], tune.sigma=0.5)
  Mean_control = mean.imp(save_control_df[[iter]])
  SVD_control = t(impute.wrapper.SVD(t(save_control_df[[iter]]), K=3))
  MICE_control = mice(save_control_df[[iter]], printFlag = F) %>% complete(.)
  RF_control = t(missForest(t(save_control_df[[iter]]))$ximp)
  
  KNN_beam = do.knn(save_beam_df[[iter]], k=floor(sqrt(nsamples/2)))
  MinProb_beam = impute.MinProb(save_beam_df[[iter]], tune.sigma=0.5)
  Mean_beam = mean.imp(save_beam_df[[iter]])
  SVD_beam = t(impute.wrapper.SVD(t(save_beam_df[[iter]]), K=3))
  MICE_beam = mice(save_beam_df[[iter]], printFlag = F) %>% complete(.)
  RF_beam = t(missForest(t(save_beam_df[[iter]]))$ximp)
  
  # Save imputed datasets
  Control_list = list(`Ground truth`=save_control_true[[iter]], KNN=KNN_control, MinProb=MinProb_control, Mean=Mean_control, SVD=SVD_control, MICE=MICE_control, RF=RF_control)
  BEAM_list = list(`Ground truth`=save_beam_true[[iter]], KNN=KNN_beam, MinProb=MinProb_beam, Mean=Mean_beam, SVD=SVD_beam, MICE=MICE_beam, RF=RF_beam)
  
  save_Control_list[[iter]] <- Control_list
  save_BEAM_list[[iter]] <- BEAM_list
}
```

Correct batch effect by ComBat
```{r}
save_ComBat_Control_list <- vector("list", length = iterations)
save_ComBat_BEAM_list <- vector("list", length = iterations)

#### Apply BECAS
for (iter in 1:iterations){
  # Set seed for reproducibility
  set.seed(iter)
  
  if (BECA_method == "ComBat"){
    # Apply ComBat
    ComBat_Control_list = lapply(save_Control_list[[iter]], function(x) do.combat.sim(x, pdat, cov=F))
    ComBat_BEAM_list = lapply(save_BEAM_list[[iter]], function(x) do.combat.sim(x, pdat, cov=F))
  }
  if (BECA_method == "limma"){
    # Apply Limma (Variables are still called ComBat)
    ComBat_Control_list = lapply(save_Control_list[[iter]], function(x) limma::removeBatchEffect(x, batch=pdat$batch))
    ComBat_BEAM_list = lapply(save_BEAM_list[[iter]], function(x) limma::removeBatchEffect(x, batch=pdat$batch))
  }
  
  # Save batch corrected datasets
  save_ComBat_Control_list[[iter]] <- ComBat_Control_list
  save_ComBat_BEAM_list[[iter]] <- ComBat_BEAM_list
}

```

Check NRMSE
```{r, fig.width=10, fig.height=5}
# RMSE function
Rmse <- function(imp, mis, true, norm = FALSE){
  imp <- as.matrix(imp)
  mis <- as.matrix(mis)
  true <- as.matrix(true)
  missIndex <- which(is.na(mis))
  errvec <- imp[missIndex] - true[missIndex]
  rmse <- sqrt(mean(errvec^2))
  if (norm) {
    rmse <- rmse/sd(true[missIndex])
  }
  return(rmse)
}


# Check NRMSE by BEAMs severity
split_beams <- function(df, batch, class){
  # Discovered by one batch only
  by1 = check_beams(df, class_factor=class, batch_factor=batch)
  by1_df = df[by1,]
  # Missing in at least one batch
  ms_by1 = check_beams(df, class_factor=class, batch_factor=batch, by_single_batch = F)
  ms_by1_only = ms_by1
  ms_by1_only[by1 == TRUE] = FALSE
  ms_by1_only_df = df[ms_by1_only,]
  # Normal missingness
  ms_df = df[ms_by1==FALSE,]
  
  return(list(noBEAMs = ms_df,
              modBEAMs = ms_by1_only_df,
              sevBEAMs = by1_df))
}

save_modBEAMs_control_NRMSE <- vector("list", length=iterations)
save_sevBEAMs_control_NRMSE <- vector("list", length=iterations)
save_modBEAMs_beam_NRMSE <- vector("list", length=iterations)
save_sevBEAMs_beam_NRMSE <- vector("list", length=iterations)

save_ComBat_modBEAMs_control_NRMSE <- vector("list", length=iterations)
save_ComBat_sevBEAMs_control_NRMSE <- vector("list", length=iterations)
save_ComBat_modBEAMs_beam_NRMSE <- vector("list", length=iterations)
save_ComBat_sevBEAMs_beam_NRMSE <- vector("list", length=iterations)

for (iter in 1:iterations){
  
  # Missing subsets
  temp_mv_control <- save_control_df[[iter]]
  temp_mv_beam <- save_beam_df[[iter]]
  beam_subsets <- split_beams(temp_mv_beam, batch=pdat$batch, class=pdat$class)
  control_subsets <- beam_subsets
  helper_list <- as.list(1:3)
  control_subsets <- lapply(helper_list, function(x){
    control_subsets[[x]] <- temp_mv_control[rownames(beam_subsets[[x]]),]
  })
  names(control_subsets) <- c("noBEAMs", "modBEAMs", "sevBEAMs")
  
  # Imp subsets
  temp_imp_control <- save_Control_list[[iter]]
  temp_imp_beam <- save_BEAM_list[[iter]]
  ComBat_temp_imp_control <- save_ComBat_Control_list[[iter]]
  ComBat_temp_imp_beam <- save_ComBat_BEAM_list[[iter]]

  
  control_imp_subsets <- beam_subsets
  beam_imp_subsets <- beam_subsets
  ComBat_control_imp_subsets <- beam_subsets
  ComBat_beam_imp_subsets <- beam_subsets

  control_imp_subsets <- lapply(helper_list, function(x){
    control_imp_subsets[[x]] <- lapply(temp_imp_control, function(j) j[rownames(beam_subsets[[x]]),])
  })
  beam_imp_subsets <- lapply(helper_list, function(x){
    beam_imp_subsets[[x]] <- lapply(temp_imp_beam, function(j) j[rownames(beam_subsets[[x]]),])
  })
  ComBat_control_imp_subsets <- lapply(helper_list, function(x){
    ComBat_control_imp_subsets[[x]] <- lapply(ComBat_temp_imp_control, function(j) j[rownames(beam_subsets[[x]]),])
  })
  ComBat_beam_imp_subsets <- lapply(helper_list, function(x){
    ComBat_beam_imp_subsets[[x]] <- lapply(ComBat_temp_imp_beam, function(j) j[rownames(beam_subsets[[x]]),])
  })

  names(control_imp_subsets) <- c("noBEAMs", "modBEAMs", "sevBEAMs")
  names(beam_imp_subsets) <- c("noBEAMs", "modBEAMs", "sevBEAMs")
  names(ComBat_control_imp_subsets) <- c("noBEAMs", "modBEAMs", "sevBEAMs")
  names(ComBat_beam_imp_subsets) <- c("noBEAMs", "modBEAMs", "sevBEAMs")

  ## Ground truth subsets
  # uncorrected
  true_df <- save_control_true[[iter]]
  ComBat_true_df <- save_ComBat_control_true[[iter]]
  
  true_subsets <- beam_subsets
  ComBat_true_subsets <- beam_subsets
  
  true_subsets <- lapply(helper_list, function(x){
    true_subsets[[x]] <- true_df[rownames(beam_subsets[[x]]),]
  })
  ComBat_true_subsets <- lapply(helper_list, function(x){
    ComBat_true_subsets[[x]] <- ComBat_true_df[rownames(beam_subsets[[x]]),]
  })
  
  names(true_subsets) <- c("noBEAMs", "modBEAMs", "sevBEAMs")
  names(ComBat_true_subsets) <- c("noBEAMs", "modBEAMs", "sevBEAMs")
  
  #### Calculate RMSE
  helper_list <- as.list(1:7)

  
    # Uncorrected
  modBEAMs_control_NRMSE <- lapply(helper_list, function(x) Rmse(control_imp_subsets[["modBEAMs"]][[x]], control_subsets[["modBEAMs"]], true_subsets[["modBEAMs"]]))
  sevBEAMs_control_NRMSE <- lapply(helper_list, function(x) Rmse(control_imp_subsets[["sevBEAMs"]][[x]], control_subsets[["sevBEAMs"]], true_subsets[["sevBEAMs"]]))
  
  modBEAMs_beam_NRMSE <- lapply(helper_list, function(x) Rmse(beam_imp_subsets[["modBEAMs"]][[x]], beam_subsets[["modBEAMs"]], true_subsets[["modBEAMs"]]))
  sevBEAMs_beam_NRMSE <- lapply(helper_list, function(x) Rmse(beam_imp_subsets[["sevBEAMs"]][[x]], beam_subsets[["sevBEAMs"]], true_subsets[["sevBEAMs"]]))
  # Corrected
  ComBat_modBEAMs_control_NRMSE <- lapply(helper_list, function(x) Rmse(ComBat_control_imp_subsets[["modBEAMs"]][[x]], control_subsets[["modBEAMs"]], ComBat_true_subsets[["modBEAMs"]]))
  ComBat_sevBEAMs_control_NRMSE <- lapply(helper_list, function(x) Rmse(ComBat_control_imp_subsets[["sevBEAMs"]][[x]], control_subsets[["sevBEAMs"]], ComBat_true_subsets[["sevBEAMs"]]))
  
  ComBat_modBEAMs_beam_NRMSE <- lapply(helper_list, function(x) Rmse(ComBat_beam_imp_subsets[["modBEAMs"]][[x]], beam_subsets[["modBEAMs"]], ComBat_true_subsets[["modBEAMs"]]))
  ComBat_sevBEAMs_beam_NRMSE <- lapply(helper_list, function(x) Rmse(ComBat_beam_imp_subsets[["sevBEAMs"]][[x]], beam_subsets[["sevBEAMs"]], ComBat_true_subsets[["sevBEAMs"]]))

  
  
  names(modBEAMs_control_NRMSE) <- c("Ground truth","KNN","Mean","MinProb","SVD","MICE","RF")
  names(sevBEAMs_control_NRMSE) <- c("Ground truth","KNN","Mean","MinProb","SVD","MICE","RF")
  names(modBEAMs_beam_NRMSE) <- c("Ground truth","KNN","Mean","MinProb","SVD","MICE","RF")
  names(sevBEAMs_beam_NRMSE) <- c("Ground truth","KNN","Mean","MinProb","SVD","MICE","RF")
  
  save_modBEAMs_control_NRMSE[[iter]] <- modBEAMs_control_NRMSE
  save_sevBEAMs_control_NRMSE[[iter]] <- sevBEAMs_control_NRMSE
  save_modBEAMs_beam_NRMSE[[iter]] <- modBEAMs_beam_NRMSE
  save_sevBEAMs_beam_NRMSE[[iter]] <- sevBEAMs_beam_NRMSE
  
  save_ComBat_modBEAMs_control_NRMSE[[iter]] <- ComBat_modBEAMs_control_NRMSE
  save_ComBat_sevBEAMs_control_NRMSE[[iter]] <- ComBat_sevBEAMs_control_NRMSE
  save_ComBat_modBEAMs_beam_NRMSE[[iter]] <- ComBat_modBEAMs_beam_NRMSE
  save_ComBat_sevBEAMs_beam_NRMSE[[iter]] <- ComBat_sevBEAMs_beam_NRMSE

}

#### Plot the data
# Uncorrected
plot_modBEAMs_control_NRMSE <- do.call(rbind, save_modBEAMs_control_NRMSE) %>% as.data.frame() %>% mutate(., BEAMs="moderate", dataset="Simulated (control)", Group="Uncorrected")
plot_sevBEAMs_control_NRMSE <- do.call(rbind, save_sevBEAMs_control_NRMSE) %>% as.data.frame() %>% mutate(., BEAMs="severe", dataset="Simulated (control)", Group="Uncorrected")

plot_modBEAMs_beam_NRMSE <- do.call(rbind, save_modBEAMs_beam_NRMSE) %>% as.data.frame() %>% mutate(., BEAMs="moderate", dataset="Simulated (BEAMs)", Group="Uncorrected")
plot_sevBEAMs_beam_NRMSE <- do.call(rbind, save_sevBEAMs_beam_NRMSE) %>% as.data.frame() %>% mutate(., BEAMs="severe", dataset="Simulated (BEAMs)", Group="Uncorrected")

# Corrected
plot_ComBat_modBEAMs_control_NRMSE <- do.call(rbind, save_ComBat_modBEAMs_control_NRMSE) %>% as.data.frame() %>% mutate(., BEAMs="moderate", dataset="Simulated (control)", Group="Corrected")
plot_ComBat_sevBEAMs_control_NRMSE <- do.call(rbind, save_ComBat_sevBEAMs_control_NRMSE) %>% as.data.frame() %>% mutate(., BEAMs="severe", dataset="Simulated (control)", Group="Corrected")

plot_ComBat_modBEAMs_beam_NRMSE <- do.call(rbind, save_ComBat_modBEAMs_beam_NRMSE) %>% as.data.frame() %>% mutate(., BEAMs="moderate", dataset="Simulated (BEAMs)", Group="Corrected")
plot_ComBat_sevBEAMs_beam_NRMSE <- do.call(rbind, save_ComBat_sevBEAMs_beam_NRMSE) %>% as.data.frame() %>% mutate(., BEAMs="severe", dataset="Simulated (BEAMs)", Group="Corrected")

colnames(plot_ComBat_modBEAMs_control_NRMSE) <- colnames(plot_modBEAMs_control_NRMSE)
colnames(plot_ComBat_sevBEAMs_control_NRMSE) <- colnames(plot_modBEAMs_control_NRMSE)
colnames(plot_ComBat_modBEAMs_beam_NRMSE) <- colnames(plot_modBEAMs_control_NRMSE)
colnames(plot_ComBat_sevBEAMs_beam_NRMSE) <- colnames(plot_modBEAMs_control_NRMSE)

plot_all_NRMSE <- rbind(plot_modBEAMs_control_NRMSE, plot_sevBEAMs_control_NRMSE, plot_modBEAMs_beam_NRMSE, plot_sevBEAMs_beam_NRMSE,
                        plot_ComBat_modBEAMs_control_NRMSE, plot_ComBat_sevBEAMs_control_NRMSE,
                        plot_ComBat_modBEAMs_beam_NRMSE, plot_ComBat_sevBEAMs_beam_NRMSE)

colnames(plot_all_NRMSE) <- colnames(plot_modBEAMs_control_NRMSE)

plot_all_NRMSE$BEAMs <- as.factor(plot_all_NRMSE$BEAMs)
plot_all_NRMSE$dataset <- factor(plot_all_NRMSE$dataset, levels= c("Simulated (control)", "Simulated (BEAMs)"))
plot_all_NRMSE$Group <- as.factor(plot_all_NRMSE$Group)
plot_all_NRMSE[,1:7] <- apply(plot_all_NRMSE, 2, as.numeric)
plot_all_NRMSE2 <- reshape2::melt(plot_all_NRMSE, id=c("BEAMs","dataset","Group"))

# Plot the results
plot_all_NRMSE2$Group <- factor(plot_all_NRMSE2$Group, levels=c("Uncorrected", "Corrected"))

ggplot(plot_all_NRMSE2[plot_all_NRMSE2$variable != "Ground truth",], aes(x=BEAMs, y=value, fill=dataset, color=dataset)) + geom_boxplot() + 
  ggh4x::facet_grid2(Group~variable, scales="free_y", independent="y") +
     scale_fill_manual(values=c("#00BFCA", "#F8766D")) +
     scale_color_manual(values=c("#0b5394", "#990000")) +
     labs(x="", y="RMSE", fill="", color="") +
     theme(legend.position = "bottom", plot.title = element_text(size=15), legend.text=element_text(face="bold"), axis.text=element_text(face="bold"), axis.text.x = element_text(angle=15, vjust=1, hjust=0.8),strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold"))
```

Check t-test p-value distribution of non-differential features
```{r, fig.height=6, fig.width=8}
save_all_ttest_results <- vector("list", length = iterations)
save_ComBat_all_ttest_results <- vector("list", length = iterations)


for (iter in 1:iterations){
  # Perform t-test on the imputed datasets
  Control_ttest = lapply(save_Control_list[[iter]], function(x) t.test.sim(x, class_factor, output="pvals"))
  BEAM_ttest = lapply(save_BEAM_list[[iter]], function(x) t.test.sim(x, class_factor, output="pvals"))
  
  # Identify and remove true differential features
  rm_features <- save_sim[[iter]]$diff.features
  Control_ttest <- lapply(Control_ttest, function(x) x[-which(names(x) %in% rm_features)])
  BEAM_ttest <- lapply(BEAM_ttest, function(x) x[-which(names(x) %in% rm_features)])
  
  ttest_results = as.data.frame(Control_ttest) %>% set_colnames(., c(c("Ground truth","KNN","MinProb","Mean","SVD","MICE","RF"))) %>% melt() %>% mutate(., Group="Simulated (control)")
  
  BEAM_ttest_results = as.data.frame(BEAM_ttest) %>% set_colnames(., c(c("Ground truth","KNN","MinProb","Mean","SVD","MICE","RF"))) %>% melt() %>% mutate(., Group="Simulated (BEAMs)")
  
  all_ttest_results = rbind(ttest_results, BEAM_ttest_results) %>% mutate(., variable = ordered(.$variable, levels=c("Ground truth","KNN","Mean","MinProb","SVD","MICE","RF")))
  
  # Repeat on the ComBat corrected datasets
  ComBat_Control_ttest = lapply(save_ComBat_Control_list[[iter]], function(x) t.test.sim(x, class_factor, output="pvals"))
  ComBat_BEAM_ttest = lapply(save_ComBat_BEAM_list[[iter]], function(x) t.test.sim(x, class_factor, output="pvals"))

  ComBat_Control_ttest <- lapply(ComBat_Control_ttest, function(x) x[-which(names(x) %in% rm_features)])
  ComBat_BEAM_ttest <- lapply(ComBat_BEAM_ttest, function(x) x[-which(names(x) %in% rm_features)])
  
  ComBat_ttest_results = as.data.frame(ComBat_Control_ttest) %>% set_colnames(., c(c("Ground truth","KNN","MinProb","Mean","SVD","MICE","RF"))) %>% melt() %>% mutate(., Group="Simulated (control)")
  
  ComBat_BEAM_ttest_results = as.data.frame(ComBat_BEAM_ttest) %>% set_colnames(., c(c("Ground truth","KNN","MinProb","Mean","SVD","MICE","RF"))) %>% melt() %>% mutate(., Group="Simulated (BEAMs)")
  
  
  ComBat_all_ttest_results = rbind(ComBat_ttest_results, ComBat_BEAM_ttest_results) %>% mutate(., variable = ordered(.$variable, levels=c("Ground truth","KNN","Mean","MinProb","SVD","MICE","RF")))
  
  # Save the results
  save_all_ttest_results[[iter]] <- all_ttest_results
  save_ComBat_all_ttest_results[[iter]] <- ComBat_all_ttest_results
}

# Plot the results
plot_all_ttest <- do.call(rbind, save_all_ttest_results)

plot_ComBat_all_ttest <- do.call(rbind, save_ComBat_all_ttest_results)

plot_ttest <- rbind(plot_all_ttest %>% mutate(., corrected = "Uncorrected"), plot_ComBat_all_ttest %>% mutate(., corrected = "Corrected"))
plot_ttest$corrected <- factor(plot_ttest$corrected, levels=c("Uncorrected","Corrected"))


ggplot(plot_ttest[plot_ttest$variable %in% c('Ground truth','KNN','Mean','MinProb'),], aes(x=value, fill=Group)) + geom_histogram(alpha=0.6, position="identity") + labs(title="",x="BH-adjusted p-value", fill="Dataset") + ggh4x::facet_grid2(corrected~variable, scales="free", independent = "y") + theme(axis.text.x=element_text(angle=45,vjust=1,hjust=0.8), strip.text = element_text(face="bold"), axis.text=element_text(face="plain"), legend.text = element_text(face="bold"), legend.position = "bottom")

ggplot(plot_ttest[plot_ttest$variable %in% c('SVD','MICE','RF'),], aes(x=value, fill=Group)) + geom_histogram(alpha=0.6, position="identity") + labs(title="",x="BH-adjusted p-value", fill="Dataset") + ggh4x::facet_grid2(corrected~variable, scales="free", independent = "y") + theme(axis.text.x=element_text(angle=45,vjust=1,hjust=0.8), strip.text = element_text(face="bold"), axis.text=element_text(face="plain"), legend.text = element_text(face="bold"), legend.position = "bottom")



```


Check TPR, FPR, Precision of DEA
```{r, fig.width=8, fig.height=8}
save_DEA_results <- vector("list", length = iterations)
confusion_matrix <- c()
for (iter in 1:iterations){
  # Get the true differential features
  control_trues <- save_sim[[iter]]$diff.features[which(save_sim[[iter]]$diff.features %in% rownames(save_control_df[[iter]]))]
  beam_trues <- save_sim[[iter]]$diff.features[which(save_sim[[iter]]$diff.features %in% rownames(save_beam_df[[iter]]))]
  
  ###### TPR Calculation
  BEAM_tpr = lapply(save_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="tpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Uncorrected")
  Control_tpr = lapply(save_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="tpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Uncorrected")
  ComBat_BEAM_tpr = lapply(save_ComBat_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="tpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Corrected")
  ComBat_Control_tpr = lapply(save_ComBat_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="tpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Corrected")
  
  tpr_res <- rbind(Control_tpr, BEAM_tpr, ComBat_Control_tpr, ComBat_BEAM_tpr) %>% mutate(., Group=factor(.$Group, levels=c("Control Uncorrected","BEAM Uncorrected","Control Corrected","BEAM Corrected")))

  
  ###### FPR Calculation
  BEAM_fpr = lapply(save_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="fpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Uncorrected")
  Control_fpr = lapply(save_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="fpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Uncorrected")
  ComBat_BEAM_fpr = lapply(save_ComBat_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="fpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Corrected")
  ComBat_Control_fpr = lapply(save_ComBat_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="fpr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Corrected")
  
  fpr_res <- rbind(Control_fpr, BEAM_fpr, ComBat_Control_fpr, ComBat_BEAM_fpr) %>% mutate(., Group=factor(.$Group, levels=c("Control Uncorrected","BEAM Uncorrected","Control Corrected","BEAM Corrected")))

  
    ###### FDR Calculation
  BEAM_fdr = lapply(save_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="fdr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Uncorrected")
  Control_fdr = lapply(save_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="fdr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Uncorrected")
  ComBat_BEAM_fdr = lapply(save_ComBat_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="fdr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Corrected")
  ComBat_Control_fdr = lapply(save_ComBat_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="fdr", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Corrected")
  
  fdr_res <- rbind(Control_fdr, BEAM_fdr, ComBat_Control_fdr, ComBat_BEAM_fdr) %>% mutate(., Group=factor(.$Group, levels=c("Control Uncorrected","BEAM Uncorrected","Control Corrected","BEAM Corrected")))

  ###### Precision Calculation
  BEAM_precision = lapply(save_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="precision", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Uncorrected")
  Control_precision = lapply(save_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="precision", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Uncorrected")
  ComBat_BEAM_precision = lapply(save_ComBat_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="precision", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Corrected")
  ComBat_Control_precision = lapply(save_ComBat_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="precision", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Corrected")
  
  precision_res <- rbind(Control_precision, BEAM_precision, ComBat_Control_precision, ComBat_BEAM_precision) %>% mutate(., Group=factor(.$Group, levels=c("Control Uncorrected","BEAM Uncorrected","Control Corrected","BEAM Corrected")))

  ###### F-score Calculation
  BEAM_fscore = lapply(save_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="fscore", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Uncorrected")
  Control_fscore = lapply(save_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="fscore", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Uncorrected")
  ComBat_BEAM_fscore = lapply(save_ComBat_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="fscore", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="BEAM Corrected")
  ComBat_Control_fscore = lapply(save_ComBat_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="fscore", fc.thres=0.5)) %>% as.data.frame() %>% melt() %>% mutate(., Group="Control Corrected")
  
  fscore_res <- rbind(Control_fscore, BEAM_fscore, ComBat_Control_fscore, ComBat_BEAM_fscore) %>% mutate(., Group=factor(.$Group, levels=c("Control Uncorrected","BEAM Uncorrected","Control Corrected","BEAM Corrected")))
  
  ###### Confusion matrix
  BEAM_confusion = lapply(save_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="confusion", fc.thres=0.5)) %>% lapply(., as.data.frame) %>% do.call(rbind, .) %>% mutate(., MVI=rownames(.)) %>% melt(., id="MVI") %>% mutate(., Group="BEAM Uncorrected")
  Control_confusion = lapply(save_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="confusion", fc.thres=0.5)) %>% lapply(., as.data.frame) %>% do.call(rbind, .) %>% mutate(., MVI=rownames(.)) %>% melt(., id="MVI") %>% mutate(., Group="Control Uncorrected")
  ComBat_BEAM_confusion = lapply(save_ComBat_BEAM_list[[iter]], function(x) tprfpr(x, class_factor, truediff=beam_trues, output="confusion", fc.thres=0.5)) %>% lapply(., as.data.frame) %>% do.call(rbind, .) %>% mutate(., MVI=rownames(.)) %>% melt(., id="MVI") %>% mutate(., Group="BEAM Corrected")
  ComBat_Control_confusion = lapply(save_ComBat_Control_list[[iter]], function(x) tprfpr(x, class_factor, truediff=control_trues, output="confusion", fc.thres=0.5)) %>% lapply(., as.data.frame) %>% do.call(rbind, .) %>% mutate(., MVI=rownames(.)) %>% melt(., id="MVI") %>% mutate(., Group="Control Corrected")
  
  confusion_res <- rbind(Control_confusion, BEAM_confusion, ComBat_Control_confusion, ComBat_BEAM_confusion) %>% mutate(., Group=factor(.$Group, levels=c("Control Uncorrected","BEAM Uncorrected","Control Corrected","BEAM Corrected")))
   if(iter == 1){
     confusion_matrix = confusion_res
   } else {
     confusion_matrix$value = confusion_matrix$value + confusion_res$value
   }
  # Save results
  save_DEA_results[[iter]]$TPR <- tpr_res
  save_DEA_results[[iter]]$FPR <- fpr_res
  save_DEA_results[[iter]]$FDR <- fdr_res
  save_DEA_results[[iter]]$Precision <- precision_res
  save_DEA_results[[iter]]$Fscore <- fscore_res

}

# Plot the results
plot_TPR <- DEA_to_plot(save_DEA_results ,output="TPR")
plot_FPR <- DEA_to_plot(save_DEA_results ,output="FPR")
plot_FDR <- DEA_to_plot(save_DEA_results ,output="FDR")
plot_Precision <- DEA_to_plot(save_DEA_results ,output="Precision")
plot_Fscore <- DEA_to_plot(save_DEA_results ,output="Fscore")

dea1 = ggplot(plot_TPR, aes(x=x, y=mean, fill=data)) +
  geom_col(position="dodge", width=0.6) +
  geom_errorbar( aes(x=x, ymin=mean-sd, ymax=mean+sd), width=0.3, size=0.5, colour="black", alpha=0.9, position = position_dodge(0.6), stat = "identity") +
  labs(x="", y="Recall (%)", fill="Dataset", title="(A) Recall (%)") + #scale_fill_hue() +
  ylim(0,100) +
  scale_fill_manual(values=c("#00BFCA", "#F8766D")) +
  theme(legend.position = "bottom", plot.title = element_text(size=15), legend.text=element_text(face="bold"), axis.text=element_text(face="bold"), axis.text.x = element_text(angle=45, vjust=1, hjust=1), strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold")) + facet_grid(~bec, scales="free_y")

# dea2 = ggplot(plot_FPR, aes(x=x, y=mean, fill=data)) +
#   geom_col(position="dodge", width=0.6) +
#   geom_errorbar( aes(x=x, ymin=pmax(mean-sd,0), ymax=mean+sd), width=0.3, size=0.5, colour="black", alpha=0.9, position = position_dodge(0.6), stat = "identity") +
#   labs(x="", y="FPR (%)", fill="Dataset", title="(B) FPR (%)") + #scale_fill_hue() +
#   ylim(0,15) +
#   scale_fill_manual(values=c("#00BFCA", "#F8766D")) +
# theme(legend.position = "bottom", plot.title = element_text(size=15), legend.text=element_text(face="bold"), axis.text=element_text(face="bold"), axis.text.x = element_text(angle=45, vjust=1, hjust=1),strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold")) + facet_grid(~bec, scales="free_y")

dea2 = ggplot(plot_FDR, aes(x=x, y=mean, fill=data)) +
  geom_col(position="dodge", width=0.6) +
  geom_errorbar( aes(x=x, ymin=pmax(mean-sd,0), ymax=mean+sd), width=0.3, size=0.5, colour="black", alpha=0.9, position = position_dodge(0.6), stat = "identity") +
  labs(x="", y="FDR (%)", fill="Dataset", title="(B) FDR (%)") + #scale_fill_hue() +
  ylim(0,102) +
  scale_fill_manual(values=c("#00BFCA", "#F8766D")) +
theme(legend.position = "bottom", plot.title = element_text(size=15), legend.text=element_text(face="bold"), axis.text=element_text(face="bold"), axis.text.x = element_text(angle=45, vjust=1, hjust=1),strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold")) + facet_grid(~bec, scales="free_y")

dea3 = ggplot(plot_Precision, aes(x=x, y=mean, fill=data)) +
  geom_col(position="dodge", width=0.6) +
  geom_errorbar( aes(x=x, ymin=mean-sd, ymax=mean+sd), width=0.3, size=0.5, colour="black", alpha=0.9, position = position_dodge(0.6), stat = "identity") +
  labs(x="", y="Precision (%)", fill="Dataset", title="(C) Precision (%)") + #scale_fill_hue() +
    ylim(0,102) +
  scale_fill_manual(values=c("#00BFCA", "#F8766D")) +
theme(legend.position = "bottom", plot.title = element_text(size=15), legend.text=element_text(face="bold"), axis.text=element_text(face="bold"), axis.text.x = element_text(angle=45, vjust=1, hjust=1),strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold")) + facet_grid(~bec, scales="free_y")

dea4 = ggplot(plot_Fscore, aes(x=x, y=mean, fill=data)) +
  geom_col(position="dodge", width=0.6) +
  geom_errorbar( aes(x=x, ymin=mean-sd, ymax=mean+sd), width=0.3, size=0.5, colour="black", alpha=0.9, position = position_dodge(0.6), stat = "identity") +
  labs(x="", y="F-score (%)", fill="Dataset", title="(D) F-score (%)") + #scale_fill_hue() +
  ylim(0,100) +
  scale_fill_manual(values=c("#00BFCA", "#F8766D")) +
theme(legend.position = "bottom", plot.title = element_text(size=15), legend.text=element_text(face="bold"), axis.text=element_text(face="bold"), axis.text.x = element_text(angle=45, vjust=1, hjust=1),strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold")) + facet_grid(~bec, scales="free_y")


deaplot.1 = ggarrange(dea1, dea2, common.legend = T, legend = "bottom")
annotate_figure(deaplot.1, top = text_grob("Simulated (Control and BEAMs) datasets", 
               color = "black", face = "bold", size = 14), bottom = text_grob("MVI method", vjust=-4))



confusion_matrix_plot <- ggplot(confusion_matrix, aes(x=MVI, y=value, fill=Group)) + geom_col(position = "dodge") + facet_wrap(~variable, scales="free")
confusion_matrix_plot
```

PCA
```{r}
save_PCA <- vector("list", length = iterations)

for (iter in 1:iterations){
  # Remove differential features
  rm_features <- save_sim[[iter]]$diff.features
  save_Control_list2 <- lapply(save_Control_list[[iter]], function(x) x[-which(rownames(x) %in% rm_features),])
  save_BEAM_list2 <- lapply(save_BEAM_list[[iter]], function(x) x[-which(rownames(x) %in% rm_features),])
  save_ComBat_Control_list2 <- lapply(save_ComBat_Control_list[[iter]], function(x) x[-which(rownames(x) %in% rm_features),])
  save_ComBat_BEAM_list2 <- lapply(save_ComBat_BEAM_list[[iter]], function(x) x[-which(rownames(x) %in% rm_features),])

  #### Perform PCA on data
  Control_PCA = lapply(save_Control_list2, function(x) prcomp(t(x), scale.=T, center=T))
  BEAM_PCA = lapply(save_BEAM_list2, function(x) prcomp(t(x), scale.=T, center=T))
  ComBat_Control_PCA = lapply(save_ComBat_Control_list2, function(x) prcomp(t(x), scale.=T, center=T))
  ComBat_BEAM_PCA = lapply(save_ComBat_BEAM_list2, function(x) prcomp(t(x), scale.=T, center=T))

  # Save the results
  save_PCA[[iter]]$Control <- Control_PCA
  save_PCA[[iter]]$BEAM <- BEAM_PCA
  save_PCA[[iter]]$ComBat_Control <- ComBat_Control_PCA
  save_PCA[[iter]]$ComBat_BEAM <- ComBat_BEAM_PCA

}

```

Create PCA plot data
```{r, fig.width=10, fig.height=8, dpi=300}
temp_list = as.list(c("Ground truth","KNN","MinProb","Mean","SVD","MICE","RF"))

#### Perform PCA on data
Control_PCA = lapply(save_Control_list2, function(x) prcomp(t(x), scale.=T, center=T))
BEAM_PCA = lapply(save_BEAM_list2, function(x) prcomp(t(x), scale.=T, center=T))
ComBat_Control_PCA = lapply(save_ComBat_Control_list2, function(x) prcomp(t(x), scale.=T, center=T))
ComBat_BEAM_PCA = lapply(save_ComBat_BEAM_list2, function(x) prcomp(t(x), scale.=T, center=T))


plot_Control_PCA <- lapply(temp_list, function(res){
  out = Control_PCA[[res]]$x[,1:2] %>% as.data.frame() %>% mutate(., Group=res, Batch=batch_factor, Class=class_factor)
  return(out)
  }) %>% do.call("rbind", .) %>% mutate(., Group=factor(.$Group, levels=c("Ground truth","KNN","Mean","MinProb","SVD","MICE","RF")), bec="Uncorrected")
plot_ComBat_Control_PCA <- lapply(temp_list, function(res){
  out = ComBat_Control_PCA[[res]]$x[,1:2] %>% as.data.frame() %>% mutate(., Group=res, Batch=batch_factor, Class=class_factor)
  return(out)
  }) %>% do.call("rbind", .) %>% mutate(., Group=factor(.$Group, levels=c("Ground truth","KNN","Mean","MinProb","SVD","MICE","RF")), bec="Corrected")
plot_BEAM_PCA <- lapply(temp_list, function(res){
  out = BEAM_PCA[[res]]$x[,1:2] %>% as.data.frame() %>% mutate(., Group=res, Batch=batch_factor, Class=class_factor)
  return(out)
  }) %>% do.call("rbind", .) %>% mutate(., Group=factor(.$Group, levels=c("Ground truth","KNN","Mean","MinProb","SVD","MICE","RF")), bec="Uncorrected")
plot_ComBat_BEAM_PCA <- lapply(temp_list, function(res){
  out = ComBat_BEAM_PCA[[res]]$x[,1:2] %>% as.data.frame() %>% mutate(., Group=res, Batch=batch_factor, Class=class_factor)
  return(out)
  }) %>% do.call("rbind", .) %>% mutate(., Group=factor(.$Group, levels=c("Ground truth","KNN","Mean","MinProb","SVD","MICE","RF")), bec="Corrected")

plot_pca_control <- rbind(plot_Control_PCA, plot_ComBat_Control_PCA) %>% mutate(., bec=factor(.$bec,levels=c("Uncorrected","Corrected")))
plot_pca_beam <- rbind(plot_BEAM_PCA, plot_ComBat_BEAM_PCA) %>% mutate(., bec=factor(.$bec,levels=c("Uncorrected","Corrected")))

sim_pca_plot_control <- ggplot(plot_pca_control, aes(x=PC1, y=PC2, fill=Batch, shape=Class)) + geom_point(size=3) + facet_grid(bec~Group) + labs(title="(B) Simulated (control) dataset") + theme(legend.position = "bottom", strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold"), title=element_text(face="bold"), axis.text = element_text(face="bold")) + scale_shape_manual(values=c(21,24)) + guides(fill = guide_legend(override.aes = list(shape=21)))
sim_pca_plot_beam <- ggplot(plot_pca_beam, aes(x=PC1, y=PC2, fill=Batch, shape=Class)) + geom_point(size=3) + facet_grid(bec~Group) + labs(title="(C) Simulated (BEAMs) dataset") + theme(legend.position = "bottom", strip.text = element_text(size=12, margin=margin(t=1,b=1), face="bold"), title=element_text(face="bold"), axis.text = element_text(face="bold")) + scale_shape_manual(values=c(21,24)) + guides(fill = guide_legend(override.aes = list(shape=21)))

sim_pca_plot <- ggarrange(sim_pca_plot_control, sim_pca_plot_beam, nrow=2, ncol=1, common.legend = T, legend="bottom")
annotate_figure(sim_pca_plot, top = text_grob("Simulation (Control and BEAMs)", 
               color = "black", face = "bold", size = 16))

```

Subset the BEAMs data matrices feature-wise by 3 levels of BEAMs severity
```{r}
# Set seed for reproducibility
set.seed(1234)

#### Identify which features belong to which subset
# Discovered by one batch only (Severe BEAMs)
by1 = check_beams(beam_df, pdat$class, pdat$batch)
by1_df = beam_df[by1,]
# Missing in at least one batch (Moderate BEAMs)
ms_by1 = check_beams(beam_df, pdat$class, pdat$batch, by_single_batch = F)
ms_by1_only = ms_by1
ms_by1_only[by1 == TRUE] = FALSE
ms_by1_only_df = beam_df[ms_by1_only,]
# Non-BEAMs
ms_df = beam_df[ms_by1==FALSE,]


#### Extract Features from each category
# Discovered by one batch only (Severe BEAMs)
imp_by1_df = lapply(BEAM_list, function(x) x[by1,])
bc_imp_by1_df = lapply(ComBat_BEAM_list, function(x) x[by1,])

# Missing in at least one batch (Moderate BEAMs)
imp_ms_by1_only_df = lapply(BEAM_list, function(x) x[ms_by1_only,])
bc_imp_ms_by1_only_df = lapply(ComBat_BEAM_list, function(x) x[ms_by1_only,])

# Non-BEAMs
imp_ms_df = lapply(BEAM_list, function(x) x[ms_by1==FALSE,])
bc_imp_ms_df = lapply(ComBat_BEAM_list, function(x) x[ms_by1==FALSE,])

#### Remove differential features
rm_features = microdf$diff.features

diff_by1=which(rownames(imp_by1_df$`Ground truth`) %in% rm_features)
diff_ms_by1=which(rownames(imp_ms_by1_only_df$`Ground truth`) %in% rm_features)
diff_ms=which(rownames(imp_ms_df$`Ground truth`) %in% rm_features)

if (length(diff_by1) > 0){
  diff_removed_by1 = lapply(imp_by1_df, function(x) x[-diff_by1,])
  bc_diff_removed_by1 = lapply(bc_imp_by1_df, function(x) x[-diff_by1,])
} else {
  diff_removed_by1 = imp_by1_df
  bc_diff_removed_by1 = bc_imp_by1_df
}
if (length(diff_ms_by1) > 0){
  diff_removed_ms_by1 = lapply(imp_ms_by1_only_df, function(x) x[-diff_ms_by1,])
  bc_diff_removed_ms_by1 = lapply(bc_imp_ms_by1_only_df, function(x) x[-diff_ms_by1,])
} else {
  diff_removed_ms_by1 = imp_ms_by1_only_df
  bc_diff_removed_ms_by1 = bc_imp_ms_by1_only_df
}
if (length(diff_ms) > 0){
  diff_removed_ms = lapply(imp_ms_df, function(x) x[-diff_ms,])
  bc_diff_removed_ms = lapply(bc_imp_ms_df, function(x) x[-diff_ms,])
} else {
  diff_removed_ms = imp_ms_df
  bc_diff_removed_ms = bc_imp_ms_df
}

#### Find subset with fewest features, then under-sample other subsets to the same size
subset_features=c(nrow(diff_removed_by1$`Ground truth`), nrow(diff_removed_ms_by1$`Ground truth`), nrow(diff_removed_ms$`Ground truth`))
fewest_features_subset=which(subset_features == min(subset_features))

ind1 = sample(x=seq(subset_features[1]),
              size=subset_features[fewest_features_subset],
              replace=FALSE)
ind2 = sample(x=seq(subset_features[2]),
              size=subset_features[fewest_features_subset],
              replace=FALSE)
ind3 = sample(x=seq(subset_features[3]),
              size=subset_features[fewest_features_subset],
              replace=FALSE)
sampled_by1 = lapply(diff_removed_by1, function(x) x[ind1,])
sampled_ms_by1 = lapply(diff_removed_ms_by1, function(x) x[ind2,])
sampled_ms = lapply(diff_removed_ms, function(x) x[ind3,])
bc_sampled_by1 = lapply(bc_diff_removed_by1, function(x) x[ind1,])
bc_sampled_ms_by1 = lapply(bc_diff_removed_ms_by1, function(x) x[ind2,])
bc_sampled_ms = lapply(bc_diff_removed_ms, function(x) x[ind3,])
```

Correlation heatmaps
```{r, fig.height = 8, fig.width = 12}
###### Correlation heatmap

# Assign annotation labels and colors
anno<-data.frame(row.names=colnames(beam_df), Batch=paste0("Batch_",batch_factor), Class=paste0("Class_",class_factor))
annoCol<-list(Batch=c(Batch_1="blue", Batch_2="red", Batch_3="orange", Batch_4="grey", Batch_5="purple1", Batch_6="black", Batch_7="yellow", Batch_8="pink", Batch_9="magenta", Batch_10="darkgreen"),
              Class=c(Class_0="yellow",
                      Class_1="black"))

# Perform Pearsons correlation and plot the heatmaps
helper_list <- as.list(1:7)
label_names <- c("Ground truth","KNN","MinProb","Mean","SVD","MICE","RF")
corheatmaps <- lapply(helper_list, function(x){
  cor_mat = cor(na.omit(sampled_by1[[x]]), method='pearson', use='complete.obs')
  h1=pheatmap(cor_mat, cluster_rows = T,cluster_cols = T, color=blues9, main="",
           show_colnames = F, show_rownames = F, annotation_col = anno, annotation_colors = annoCol,
           annotation_legend = F, silent = T, treeheight_row = 0) %>% as.ggplot()
  cor_mat = cor(na.omit(sampled_ms_by1[[x]]), method='pearson', use='complete.obs')
  h2=pheatmap(cor_mat, cluster_rows = T,cluster_cols = T, color=blues9, main="",
           show_colnames = F, show_rownames = F, annotation_col = anno, annotation_colors = annoCol,
           annotation_legend = F, silent = T, treeheight_row = 0) %>% as.ggplot()
  cor_mat = cor(na.omit(sampled_ms[[x]]), method='pearson', use='complete.obs')
  h3=pheatmap(cor_mat, cluster_rows = T,cluster_cols = T, color=blues9, main="",
           show_colnames = F, show_rownames = F, annotation_col = anno, annotation_colors = annoCol,
           annotation_legend = F, silent = T, treeheight_row = 0) %>% as.ggplot()
  
  # Corrected
  cor_mat = cor(na.omit(bc_sampled_by1[[x]]), method='pearson', use='complete.obs')
  h4=pheatmap(cor_mat, cluster_rows = T,cluster_cols = T, color=blues9, main="",
           show_colnames = F, show_rownames = F, annotation_col = anno, annotation_colors = annoCol,
           annotation_legend = F, silent = T, treeheight_row = 0) %>% as.ggplot()
  cor_mat = cor(na.omit(bc_sampled_ms_by1[[x]]), method='pearson', use='complete.obs')
  h5=pheatmap(cor_mat, cluster_rows = T,cluster_cols = T, color=blues9, main="",
           show_colnames = F, show_rownames = F, annotation_col = anno, annotation_colors = annoCol,
           annotation_legend = F, silent = T, treeheight_row = 0) %>% as.ggplot()
  cor_mat = cor(na.omit(bc_sampled_ms[[x]]), method='pearson', use='complete.obs')
  h6=pheatmap(cor_mat, cluster_rows = T,cluster_cols = T, color=blues9, main="",
          show_colnames = F, show_rownames = F, annotation_col = anno, annotation_colors = annoCol,
           annotation_legend = F, silent = T, treeheight_row = 0) %>% as.ggplot()
  # out_plot = ggarrange(h1[[4]],h2[[4]],h3[[4]],h4[[4]],h5[[4]],h6[[4]], common.legend=T, legend="bottom")
  out_plot = ggarrange(h3,h2,h1,h6,h5,h4, common.legend=T, legend="bottom")

  # Create title
  text_grob <- text_grob(label = label_names[x], 
                       face = "bold", 
                       size = 16, 
                       hjust = 0.5)
  out_plot <- annotate_figure(out_plot, top = text_grob)
})

for (i in 1:7){
  print(corheatmaps[[i]])
}
```

Plot a feature from the severe BEAMs group in a KNN imputed dataset to see what caused the p-value inflation
```{r, fig.height=6}
# Find a feature with inflated p-value
pvals <- BEAM_ttest$KNN[rownames(sampled_by1$KNN)] # Extract the p-values
signif <- which(pvals < 0.05)
feat <- signif[1]
ori_feature <- data.frame(values=sampled_by1$`Ground truth`[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Ground truth")
imp_feature <- data.frame(values=sampled_by1$KNN[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Imputed")
all_feature <- rbind(ori_feature, imp_feature)

# Separate batches by vertical line
batch_lines <- seq(from=0, to=nsamples, by=(classbatch_samples*2)) %>% .[-c(1, length(.))]
batch_lines <- batch_lines + 0.5


par(mfrow=c(2,2))
plot(sampled_by1$`Ground truth`[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(A) Ground truth", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(beam_df[rownames(sampled_by1$`Ground truth`)[feat],], col=class_factor, pch=19, main="", ylab="",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(B) BEAMs introduced", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(sampled_by1$KNN[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(C) KNN imputed", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(bc_sampled_by1$KNN[feat,], col=class_factor, pch=19, main="", ylab="",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(D) KNN imputed and ComBat corrected", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)
```

Plot a feature from the severe BEAMs group in a RF imputed dataset to see what caused the p-value inflation
```{r, fig.height=6}
# Find a feature with inflated p-value
pvals <- BEAM_ttest$RF[rownames(sampled_by1$RF)] # Extract the p-values
signif <- which(pvals < 0.05)
feat <- signif[1]
ori_feature <- data.frame(values=sampled_by1$`Ground truth`[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Ground truth")
imp_feature <- data.frame(values=sampled_by1$RF[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Imputed")
all_feature <- rbind(ori_feature, imp_feature)

# Separate batches by vertical line
batch_lines <- seq(from=0, to=nsamples, by=(classbatch_samples*2)) %>% .[-c(1, length(.))]
batch_lines <- batch_lines + 0.5


par(mfrow=c(2,2))
plot(sampled_by1$`Ground truth`[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(A) Ground truth", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(beam_df[rownames(sampled_by1$`Ground truth`)[feat],], col=class_factor, pch=19, main="", ylab="",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(B) BEAMs introduced", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(sampled_by1$RF[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(C) RF imputed", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(bc_sampled_by1$RF[feat,], col=class_factor, pch=19, main="", ylab="",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(D) RF imputed and ComBat corrected", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)
```

Plot a feature from the moderate BEAMs group in a mean imputed dataset to see what caused the poor batch effect correction
```{r, fig.height=6}
# Find a feature with inflated p-value
pvals <- BEAM_ttest$Mean[rownames(sampled_ms_by1$Mean)] # Extract the p-values
signif <- which(pvals < 0.05)
feat <- 3
ori_feature <- data.frame(values=sampled_ms_by1$`Ground truth`[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Ground truth")
imp_feature <- data.frame(values=sampled_ms_by1$Mean[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Imputed")
all_feature <- rbind(ori_feature, imp_feature)

# Separate batches by vertical line
batch_lines <- seq(from=0, to=nsamples, by=(classbatch_samples*2)) %>% .[-c(1, length(.))]
batch_lines <- batch_lines + 0.5

par(mfrow=c(2,2))
plot(sampled_ms_by1$`Ground truth`[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(A) `Ground truth`", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(beam_df[rownames(sampled_ms_by1$`Ground truth`)[feat],], col=class_factor, pch=19, main="", ylab="",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(B) BEAMs introduced", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(sampled_ms_by1$Mean[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(C) Mean imputed", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(bc_sampled_ms_by1$Mean[feat,], col=class_factor, pch=19, main="", ylab="",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(D) Mean imputed and ComBat corrected", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)
```

Plot a feature from the severe BEAMs group in a MinProb imputed dataset to see what caused the p-value inflation
```{r, fig.height=6}
# Find a feature with inflated p-value
pvals <- BEAM_ttest$MinProb[rownames(sampled_by1$MinProb)] # Extract the p-values
signif <- which(pvals < 0.05)
feat <- 1#signif[2]
ori_feature <- data.frame(values=sampled_by1$`Ground truth`[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Ground truth")
imp_feature <- data.frame(values=sampled_by1$MinProb[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Imputed")
all_feature <- rbind(ori_feature, imp_feature)

# Separate batches by vertical line
batch_lines <- seq(from=0, to=nsamples, by=(classbatch_samples*2)) %>% .[-c(1, length(.))]
batch_lines <- batch_lines + 0.5

par(mfrow=c(2,2))
plot(sampled_by1$`Ground truth`[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(A) `Ground truth`", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(beam_df[rownames(sampled_by1$`Ground truth`)[feat],], col=class_factor, pch=19, main="", ylab="",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(B) BEAMs introduced", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(sampled_by1$MinProb[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(C) MinProb imputed", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(bc_sampled_by1$MinProb[feat,], col=class_factor, pch=19, main="", ylab="",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(D) MinProb imputed and ComBat corrected", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)
```

Plot a feature from the severe BEAMs group in a SVD imputed dataset to see what caused the p-value inflation
```{r, fig.height=6}
# Find a feature with inflated p-value
pvals <- BEAM_ttest$SVD[rownames(sampled_by1$SVD)] # Extract the p-values
signif <- which(pvals < 0.05)
feat <- 1#signif[2]
ori_feature <- data.frame(values=sampled_by1$`Ground truth`[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Ground truth")
imp_feature <- data.frame(values=sampled_by1$SVD[feat,], class=class_factor, batch=batch_factor, samples=seq(nsamples), group="Imputed")
all_feature <- rbind(ori_feature, imp_feature)

# Separate batches by vertical line
batch_lines <- seq(from=0, to=nsamples, by=(classbatch_samples*2)) %>% .[-c(1, length(.))]
batch_lines <- batch_lines + 0.5

par(mfrow=c(2,2))
plot(sampled_by1$`Ground truth`[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(A) `Ground truth`", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(beam_df[rownames(sampled_by1$`Ground truth`)[feat],], col=class_factor, pch=19, main="", ylab="",xlab="", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(B) BEAMs introduced", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(sampled_by1$SVD[feat,], col=class_factor, pch=19, main="", ylab="Values",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(C) SVD imputed", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)

plot(bc_sampled_by1$SVD[feat,], col=class_factor, pch=19, main="", ylab="",xlab="Samples", cex=2, cex.lab=1.5, cex.axis=1.5)
title(main="(D) SVD imputed and ComBat corrected", cex.main=1.5, adj=0)
abline(v = batch_lines, col=alpha("#3b3b3b",0.5), lwd=2, lty=2)
```

Session info
```{r}
sessionInfo()
```
